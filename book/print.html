<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js oranda-dark">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>cargo-dist</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">
        <link rel="stylesheet" href="oranda-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "oranda-dark" : "oranda-dark";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('orandamdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('orandamdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('orandamdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('oranda-dark')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="install.html"><strong aria-hidden="true">2.</strong> Install</a></li><li class="chapter-item expanded "><a href="way-too-quickstart.html"><strong aria-hidden="true">3.</strong> Way Too Quick Start</a></li><li class="chapter-item expanded "><a href="guide.html"><strong aria-hidden="true">4.</strong> Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="simple-guide.html"><strong aria-hidden="true">4.1.</strong> A Simple Application</a></li><li class="chapter-item expanded "><a href="workspace-guide.html"><strong aria-hidden="true">4.2.</strong> More Complex Workspaces</a></li><li class="chapter-item expanded "><a href="cargo-release-guide.html"><strong aria-hidden="true">4.3.</strong> Using cargo-release</a></li></ol></li><li class="chapter-item expanded "><a href="reference.html"><strong aria-hidden="true">5.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">5.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="config.html"><strong aria-hidden="true">5.2.</strong> Config</a></li><li class="chapter-item expanded "><a href="artifacts.html"><strong aria-hidden="true">5.3.</strong> Artifacts</a></li><li class="chapter-item expanded "><a href="installers.html"><strong aria-hidden="true">5.4.</strong> Installers</a></li><li class="chapter-item expanded "><a href="cli.html"><strong aria-hidden="true">5.5.</strong> CLI Manual</a></li><li class="chapter-item expanded "><a href="schema.html"><strong aria-hidden="true">5.6.</strong> dist-manifest.json</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="oranda-dark">Axo Dark</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="oranda-light">Axo Light</button></li>

                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">cargo-dist</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/axodotdev/cargo-dist" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>cargo-dist extends Cargo to support all the extra things you want to do when building the final shippable binaries for an application, so we can turn this:</p>
<pre><code class="language-sh">git commit -am &quot;Chore: 0.1.0 release&quot;
git tag &quot;v0.1.0&quot;
git push
git push --tags
</code></pre>
<p>into this:</p>
<p><img src="./img/simple-github-release.png" alt="A Github Release for &quot;my-app 0.1.0&quot; with shell-script installers and tarballs of prebuilt binaries" /></p>
<p>Locally, cargo-dist can do the following:</p>
<ul>
<li>Picking good build flags for &quot;shippable binaries&quot;</li>
<li>Making zips and <a href="./installers.html">installers</a> for the resulting binaries</li>
<li>Generating machine-readable manifests so other tools can understand the results</li>
</ul>
<p>Being able to build a zip on your own machine is nice and all, but in practice you probably want to have infrastructure for building and hosting the binaries for all the platforms you care about. To help streamline this, cargo-dist has builtin support for bringing up your infra (currently only Github CI and Github Releases, but we intended to support other platforms in subsequent releases)!</p>
<p>Just run <code>cargo dist init</code> and it will <strong>generate its own CI scripts</strong> which:</p>
<ul>
<li>Waits for you to push a git tag for a new version (v1.0.0, my-app-v1.0.0, ...)</li>
<li>Selects what apps in your workspace to announce new releases for based on that tag </li>
<li>Creates a draft Github Release to announce the apps in and host the downloads</li>
<li>Adds the relevant release notes from your RELEASES or CHANGELOG file</li>
<li>Spins up machines to build the selected apps for your supported platforms</li>
<li>Uploads the various zips/<a href="./installers.html">installers</a> to the Github Release</li>
<li>On success, publishes the Github Releases</li>
</ul>
<p>The scripts are intentionally minimal, and each machine's job roughly amounts to &quot;install cargo-dist&quot;, &quot;run it exactly once&quot;, &quot;upload the artifacts it reported&quot;. It will always be <em>easier</em> to do builds in CI, but we want to shrink that gap as much as possible. </p>
<p><strong>We want you to be able to copy that one cargo-dist invocation CI did, run it on your machine, and get the same results without any fuss</strong> (not to bit-level precision, but to the kinds of precision normal people expect from cargo builds). No setting up docker, no weird linux-only shell scripts that assume a bunch of tools were setup in earlier CI steps.</p>
<p>The main obstacle to this is &quot;<a href="https://github.com/axodotdev/cargo-dist/issues/74">cross-compilation is hard</a>&quot;, but other folks are making that easier every day, and eventually we'll help you with that too.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install"><a class="header" href="#install">Install</a></h1>
<ul>
<li><a href="install.html#install-prebuilt-binaries-with-cargo-binstall">Install Prebuilt Binaries With cargo-binstall</a></li>
<li><a href="install.html#build-from-source-with-cargo">Build From Source With Cargo</a></li>
<li><a href="install.html#installation-on-arch-linux">Installation on Arch Linux</a></li>
<li><a href="install.html#download-prebuilt-binaries-from-github-releases">Download Prebuilt Binaries From Github Releases</a></li>
<li><a href="install.html#use-the-installer-scripts">Use The Installer Scripts</a></li>
</ul>
<p>Surprise! The tool for prebuilt shippable binaries has way too many ways to install it!
Whichever way you choose to install it, it should be invocable as <code>cargo dist ...</code>. If you insist on invoking the binary directly as <code>cargo-dist</code> you must still add the extra <code>dist</code> arg and invoke it as <code>cargo-dist dist ...</code> (a quirk of the way cargo invokes subcommands).</p>
<h2 id="install-prebuilt-binaries-with-cargo-binstall"><a class="header" href="#install-prebuilt-binaries-with-cargo-binstall">Install Prebuilt Binaries With cargo-binstall</a></h2>
<pre><code class="language-sh">cargo binstall cargo-dist
</code></pre>
<h2 id="build-from-source-with-cargo"><a class="header" href="#build-from-source-with-cargo">Build From Source With Cargo</a></h2>
<pre><code class="language-sh">cargo install cargo-dist --locked --profile=dist
</code></pre>
<p>(<code>--profile=dist</code> is the profile we build our shippable binaries with, it's optional.)</p>
<h2 id="installation-on-arch-linux"><a class="header" href="#installation-on-arch-linux">Installation on Arch Linux</a></h2>
<p>Arch Linux users can install <code>cargo-dist</code> from the <a href="https://archlinux.org/packages/extra/x86_64/cargo-dist/">extra repository</a> using <a href="https://wiki.archlinux.org/title/Pacman">pacman</a>:</p>
<pre><code class="language-sh">pacman -S cargo-dist
</code></pre>
<h2 id="download-prebuilt-binaries-from-github-releases"><a class="header" href="#download-prebuilt-binaries-from-github-releases">Download Prebuilt Binaries From Github Releases</a></h2>
<p><a href="https://github.com/axodotdev/cargo-dist/releases/latest">See The Latest Release</a>!</p>
<h2 id="use-the-installer-scripts"><a class="header" href="#use-the-installer-scripts">Use The Installer Scripts</a></h2>
<p><strong>NOTE: these installer scripts are currently under-developed and will place binaries in <code>$HOME/.cargo/bin/</code> without properly informing Cargo of the change, resulting in <code>cargo uninstall cargo-dist</code> and some other things not working. They are however suitable for quickly bootstrapping cargo-dist in temporary environments (like CI) without any other binaries being installed.</strong></p>
<p>Linux and macOS:</p>
<pre><code class="language-sh">curl --proto '=https' --tlsv1.2 -LsSf https://github.com/axodotdev/cargo-dist/releases/latest/download/cargo-dist-installer.sh | sh
</code></pre>
<p>Windows PowerShell:</p>
<pre><code class="language-sh">irm https://github.com/axodotdev/cargo-dist/releases/latest/download/cargo-dist-installer.ps1 | iex
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="way-too-quickstart"><a class="header" href="#way-too-quickstart">Way-Too-Quickstart</a></h1>
<ul>
<li><a href="way-too-quickstart.html#setup">Setup</a></li>
<li><a href="way-too-quickstart.html#test-locally">Test Locally</a>
<ul>
<li><a href="way-too-quickstart.html#build-for-the-current-platform">Build For The Current Platform</a></li>
<li><a href="way-too-quickstart.html#check-what-ci-will-build">Check What CI Will Build</a></li>
</ul>
</li>
<li><a href="way-too-quickstart.html#cut-a-release-trigger-github-ci">Cut A Release (Trigger Github CI)</a>
<ul>
<li><a href="way-too-quickstart.html#streamlining-cutting-a-release">Streamlining Cutting A Release</a></li>
</ul>
</li>
</ul>
<blockquote>
<p>TLDR: cargo-dist is a souped up version of <code>cargo build</code> which handles building tarballs/zips and <a href="./installers.html">installers</a>. It also knows how to generate Github CI for orchestrating itself and uploading its output to a new Github Release. You can use cargo-dist if you don't care about that CI stuff, but this guide assumes that you do.</p>
<p>This quickstart is a bit <em>too</em> quick because there's some important nuances to &quot;announcing and building releases&quot; that depend on the way you like to structure and version your workspace. We will blatantly ignore those nuances and show you the Happiest Happy Path (a workspace with one crate that defines a binary). Checkout <a href="./guide.html">the guide</a> for more details on what you should <em>actually</em> do.</p>
</blockquote>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>Setting up just requires you to <a href="./install.html">install cargo-dist</a> and then run <code>cargo dist init</code> in your <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">Cargo workspace</a>. This command interactively walks you through configuration options, and can be run again whenever you want to change your settings. Since this is the <em>way-too</em>-quickstart, we pass <code>--yes</code> to auto-accept all defaults!</p>
<pre><code class="language-sh"># install tools (build from source is the most portable option)
cargo install cargo-dist

# setup cargo-dist in your project (--yes to accept defaults)
cargo dist init --yes
git add .
git commit -am &quot;wow shiny new cargo-dist CI!&quot;
</code></pre>
<p>The one-time setup will add a decent default configuration to your root Cargo.toml and generate CI for orchestrating itself in <code>.github/workflows/release.yml</code>. If the CI file isn't created, this probably means you don't have <code>repository = &quot;https://github.com/...&quot;</code> consistently set in your Cargo.toml(s).</p>
<h2 id="test-locally"><a class="header" href="#test-locally">Test Locally</a></h2>
<p>When testing out cargo-dist locally, the two biggest things you might be interested in are:</p>
<ol>
<li>build for the current platform (<code>cargo dist build</code>)</li>
<li>check what CI will build (<code>cargo dist plan</code>)</li>
</ol>
<h3 id="build-for-the-current-platform"><a class="header" href="#build-for-the-current-platform">Build For The Current Platform</a></h3>
<pre><code class="language-sh">cargo dist build
</code></pre>
<p><img src="./img/quickstart-build.png" alt="Running &quot;cargo dist build&quot; on a project, resulting in the application getting built and bundled into a .zip, and an &quot;installer.ps1&quot; script getting generated. Paths to these files are printed along with some metadata." /></p>
<p>The <a href="./cli.html#cargo-dist-build">build command</a> will by default try to build things for the computer you're running it on. So if you run it on linux you might get a <code>tar.xz</code> containing your binary and an installer shell script, but if you run it on windows you might get a <code>zip</code> and an installer <em>power</em>shell script.</p>
<p>cargo-dist will then spit out paths to the files it created, so you can inspect their contents and try running them (<strong>note that installer scripts probably won't be locally runnable, because they will try to fetch their binaries from Github</strong>).</p>
<p>See <a href="./concepts.html#artifact-modes-selecting-artifacts">artifact modes</a> for more advanced details on selecting what things cargo-dist should build.</p>
<h3 id="check-what-ci-will-build"><a class="header" href="#check-what-ci-will-build">Check What CI Will Build</a></h3>
<pre><code class="language-sh">cargo dist plan
</code></pre>
<p><img src="./img/quickstart-build.png" alt="Running &quot;cargo dist plan&quot; on a project, producing a full printout of the tarballs/zips that will be produced for all platforms (mac, linux, windows), and all installers (shell, powershell)" /></p>
<p>The <a href="./cli.html#cargo-dist-plan">plan command</a> should be running the exact same logic that cargo-dist's generated CI will run, but without actually building anything. This lets you quickly check what cutting a new release will produce. It will also try to catch any inconsistencies that could make the CI error out.</p>
<h2 id="cut-a-release-trigger-github-ci"><a class="header" href="#cut-a-release-trigger-github-ci">Cut A Release (Trigger Github CI)</a></h2>
<p>cargo-dist largely doesn't care about the details of how you prepare your release, and intentionally doesn't provide tools to streamline it (see the next section for some recommendations). All it cares about is you getting your main branch into the state you want, and then pushing a properly formatted git tag like &quot;v0.1.0&quot;. Here's a super bare-bones release process:</p>
<pre><code class="language-sh"># &lt;manually update the version of your crate, run tests, etc&gt;

# commit and push to main (can be done with a PR)
git commit -am &quot;chore: Release version 0.1.0&quot;
git push

# publish to crates.io (optional)
cargo publish

# actually push the tag up (this triggers cargo-dist's CI)
git tag v0.1.0
git push --tags
</code></pre>
<p>The important parts are that you update the crates you want to release/announce to the desired version and push a git tag with that version. (prefixed with <code>v</code>!)</p>
<p>At this point you're done! The generated CI script should pick up the ball and create a Github Release with all your builds over the next few minutes!</p>
<h3 id="streamlining-cutting-a-release"><a class="header" href="#streamlining-cutting-a-release">Streamlining Cutting A Release</a></h3>
<p>You may have noticed &quot;cut a release&quot; still has a lot of tedious work. That's because we recommend using <a href="https://github.com/crate-ci/cargo-release">cargo-release</a> to streamline the last step, which in <em>simple workspaces</em> will do exactly the same thing as above (but more robustly):</p>
<pre><code class="language-sh"># install tools
cargo install cargo-release

# cut a release
cargo release 0.1.0
</code></pre>
<p>(I left off the <code>--execute</code> flag from <code>cargo-release</code> so you won't accidentally break anything if you really did just copy paste that 😇)</p>
<p>For more details on using cargo-release with cargo-dist, see <a href="./cargo-release-guide.html">the guide for that</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guide"><a class="header" href="#guide">Guide</a></h1>
<p>The cargo-dist Guide is the &quot;beginner&quot; documentation that walks you through simple usage and then introduces more complex situations as you go. More advanced documentation can be found in &quot;<a href="./concepts.html">concepts</a>&quot;.</p>
<p>If you have a <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">Cargo Workspace</a> with a single Cargo package that <code>cargo install</code> works for, and just want zips containing prebuilt binaries for the major desktop platforms, that should Just Work as described in the <a href="./way-too-quickstart.html">Way-Too-Quickstart</a>. Things get more complicated if you want to:</p>
<ul>
<li>have more packages in your <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">Cargo Workspace</a> (libraries, multiple binaries, ...)</li>
<li>have additional steps in your build (configure the system, add files, ...)</li>
<li>build various kinds of <a href="./artifacts.html#installers">installers</a> (curl-sh scripts, npm packages, msi, ...)</li>
</ul>
<p>Gonna be blunt and say that cargo-dist is still in early days and we still need to implement a lot of stuff to better support all the things people want to do with Shippable Builds. If what you want to do doesn't seem properly supported and we don't have <a href="https://github.com/axodotdev/cargo-dist/issues">an issue</a> for it, absolutely file one so we can hash it out!</p>
<p>The guide will start by explaining the simple case, and then explain the more complicated cases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guide-a-simple-application"><a class="header" href="#guide-a-simple-application">Guide: A Simple Application</a></h1>
<ul>
<li><a href="simple-guide.html#setup-and-updates">Setup (and Updates)</a>
<ul>
<li><a href="simple-guide.html#the-dist-profile">The &quot;dist&quot; Profile</a></li>
<li><a href="simple-guide.html#the-workspace-config">The Workspace Config</a></li>
<li><a href="simple-guide.html#the-ci-script">The CI Script</a></li>
<li><a href="simple-guide.html#finishing-setup">Finishing Setup</a></li>
</ul>
</li>
<li><a href="simple-guide.html#cutting-releases">Cutting Releases</a>
<ul>
<li><a href="simple-guide.html#release-notes">Release Notes</a></li>
</ul>
</li>
</ul>
<p>Let's start with the kind of simple <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">Cargo Workspace</a> you would get from <code>cargo new my-app</code> (or <code>cargo init my-app</code>): a single package that defines a <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries">binary target</a>. This is exactly the situation the <a href="./way-too-quickstart.html">Way-Too-Quickstart</a> should work perfectly for. Here we're going to take it a bit slower.</p>
<p>Our goal will be to setup a Github CI workflow that announces a new release of our application with a Github Release. The workflow will also build our application for the 3 major desktop platforms, wrap the binaries in zips/tarballs, and upload them to the Github Release. The Github Release's text will also include the relevant release notes from our RELEASES.md file.</p>
<p>The workflow will be triggered whenever you push a <a href="https://git-scm.com/book/en/v2/Git-Basics-Tagging">Git Tag</a> specifying the application's new version, like &quot;v1.0.0&quot;. Don't worry, you won't need to write those workflows yourself, cargo-dist will generate them for you! </p>
<blockquote>
<p>TO BE EXTREMELY PEDANTIC: The workflow will trigger whenever Github sees that the git tag <em>and</em> the commit it refers to are part of the repo <em>and</em> the timestamp(?) of both(?) is <em>after</em> the commit that introduced the workflow's yml file. That last part is an absolute headache, and may require you to delete the tag <em>both locally and on github</em> if you created it before the workflow. Basically, setup cargo-dist <em>before</em> you start cutting releases!</p>
</blockquote>
<h2 id="setup-and-updates"><a class="header" href="#setup-and-updates">Setup (and Updates)</a></h2>
<p>To setup cargo-dist on our project (after we've <a href="./install.html">installed it</a>), we &quot;need&quot; to run <code>cargo dist init</code>, which will provide us with a series of interactive prompts and explanations to configure our project. The recommended option can always be selected by hitting ENTER, and you can automate that by just passing <code>--yes</code>.</p>
<p>You can rerun <code>init</code> as many times as you want, as it also functions as an &quot;update&quot; command for your config. This is especially convenient for updating your project to the version of cargo-dist you're running, as it will prompt you to do that whenever the versions don't match (refusing to proceed if declined).</p>
<pre><code class="language-sh">cargo dist init
</code></pre>
<p><a href="./cli.html#cargo-dist-init"><code>init</code></a> on its own just edits your Cargo.toml to include the recommended defaults. If you have enabled CI support, it will also run <code>cargo dist generate-ci</code> after setting things up. This ensures your config and your CI scripts are in sync, but will unfortunately clobber any hand-edits you made to the scripts.</p>
<p>Let's look at those defaults that were added (yes those comments are generated too, you will never stop me from adding more docs!!!):</p>
<pre><code class="language-toml"># The profile that 'cargo dist' will build with
[profile.dist]
inherits = &quot;release&quot;
lto = &quot;thin&quot;

# Config for 'cargo dist'
[workspace.metadata.dist]
# The preferred cargo-dist version to use in CI (Cargo.toml SemVer syntax)
cargo-dist-version = &quot;0.0.6&quot;
# The preferred Rust toolchain to use in CI (rustup toolchain syntax)
rust-toolchain-version = &quot;1.67.1&quot;
# CI backends to support (see 'cargo dist generate-ci')
ci = [&quot;github&quot;]
# The installers to generate for each app
installers = []
# Target platforms to build apps for (Rust target-triple syntax)
targets = [&quot;x86_64-unknown-linux-gnu&quot;, &quot;x86_64-apple-darwin&quot;, &quot;x86_64-pc-windows-msvc&quot;, &quot;aarch64-apple-darwin&quot;]
</code></pre>
<blockquote>
<p>If your config doesn't have <code>ci = [&quot;github&quot;]</code> by default, then you probably don't have <code>repository = &quot;https://github.com/...&quot;</code> consistently set in your Cargo.toml(s). The rest of this guide will assume you did. cargo-dist will work fine without it, you just won't get Github CI integration or <a href="./installers.html">installers</a>.</p>
</blockquote>
<h3 id="the-dist-profile"><a class="header" href="#the-dist-profile">The &quot;dist&quot; Profile</a></h3>
<p>First let's talk about <code>[profile.dist]</code>. This is a custom <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">Cargo Profile</a> that cargo-dist will use to build your app. If you want to, you can use it yourself by passing <code>--profile=dist</code> to cargo (i.e. <code>cargo run --profile=dist</code>). We define a separate profile from the normal &quot;release&quot; one so that you can be comfortable giving your Shippable Builds more aggressive settings without making local development too tedious.</p>
<p>In this case the default profile cargo-dist recommends is essentially the same as --release (hence <code>inherits = &quot;release&quot;</code>), but with <a href="https://doc.rust-lang.org/cargo/reference/profiles.html#lto">thin LTO</a> enabled (<code>lto = &quot;thin&quot;</code>). This will make the build take longer, but produce more optimized builds.</p>
<p>cargo-dist uses the existence of <code>[profile.dist]</code> in your Cargo.toml to detect if your project has been properly initialized, and will generally refuse to run other commands otherwise. Sorry but you can't delete the profile!</p>
<h3 id="the-workspace-config"><a class="header" href="#the-workspace-config">The Workspace Config</a></h3>
<p>Next let's talk about <code>[workspace.metadata.dist]</code>. Cargo allows other tools to include their own project-wide settings in this kind of <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#the-metadata-table">metadata table</a>. See <a href="./config.html">config</a> for the full set of options, but here we'll look at the defaults.</p>
<p><code>cargo-dist-version = &quot;0.0.6&quot;</code> is cargo-dist recording its own version in your config for the sake of reproducibility and documentation. When you run <a href="./cli.html#cargo-dist-generate-ci">generate-ci</a> the resulting CI scripts will use that version of cargo-dist.</p>
<p><code>rust-toolchain-version = &quot;1.67.1&quot;</code> is the Rust toolchain that is considered &quot;ideal&quot; for building your application, recorded for the sake of reproducibility and documentation. This is in contrast to the builtin Cargo <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-rust-version-field">rust-version</a> which is used to specify the <em>minimum</em> supported Rust version. When you run <a href="./cli.html#cargo-dist-generate-ci">generate-ci</a> the resulting CI scripts will install that version of the Rust toolchain with <a href="https://rustup.rs/">rustup</a>. There's nothing special about the chosen value, it's just a hardcoded &quot;recent stable version&quot;.</p>
<p><code>ci = [&quot;github&quot;]</code> lets subsequent runs of <a href="./cli.html#cargo-dist-generate-ci">generate-ci</a> know what CI scripts to generate. Its presence also enables certain Github-specific features like generating the body for a Github Release and telling installers to fetch binaries from a Github Release. It will be enabled by default if you have <code>repository = &quot;https://github.com/...&quot;</code> consistently set in your Cargo.toml(s). (&quot;github&quot; is currently the only supported CI backend.) </p>
<p><code>installer = []</code> is just saying that we haven't enabled any <a href="./installers.html">installers</a>. Installers are intentionally excluded here to keep this example focused.</p>
<p><code>targets = ...</code> is listing the <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">platforms</a> to build your application for. In this case, because we didn't specify the targets with <code>--target</code>, <a href="./cli.html#cargo-dist-init">init</a> has selected the &quot;recommended desktop suite&quot;: &quot;x64 linux&quot;, &quot;x64 macos&quot;, &quot;x64 windows&quot;, and &quot;arm64 macos (Apple silicon)&quot;. In v0.0.6 these are the only properly supported choices, because we wanted to get the core of cargo-dist solid first. Future versions should hopefully introduce proper support for important targets like &quot;musl linux&quot;.</p>
<h3 id="the-ci-script"><a class="header" href="#the-ci-script">The CI Script</a></h3>
<p>Because we set <code>ci = [&quot;github&quot;]</code>, <a href="./cli.html#cargo-dist-init">init</a> invoked <a href="./cli.html#cargo-dist-generate-ci">generate-ci</a> for us. Creating the Github CI workflow we wanted at <code>.github/workflows/release.yml</code>. Rather than including the full text here, I'll just link <a href="https://github.com/axodotdev/cargo-dist/blob/main/.github/workflows/release.yml">cargo-dist's own release.yml</a>, because cargo-dist is self-hosting and has an extremely boring build/config that is basically equivalent to the one we're looking at in this example.</p>
<p>The first thing you might notice is that there's a <em>lot</em> of comments describing the script. As always: you will never stop me from writing more docs and shoving them in your face. Actually ok you <em>can</em> stop me because I need to write a lot of docs here and those comments are already decent docs. Feel free to peruse them to get a feel for it.</p>
<p>One thing I want to emphasize is that each job of the workflow essentially boils down to &quot;install cargo-dist, run cargo-dist exactly once, then upload the files it tells you to&quot;. Ideally this means you can run that one cargo-dist command and get the same things that CI produced!</p>
<p>Anyway, the CI totally does all the things we said it should! Yay!</p>
<h3 id="finishing-setup"><a class="header" href="#finishing-setup">Finishing Setup</a></h3>
<p>Now that we've run <code>cargo dist init</code>, all we need to do is commit the results and push them up:</p>
<pre><code class="language-sh">git add .
git commit -am &quot;wow cool new cargo-dist CI!&quot;
git push
</code></pre>
<p>Actually wait we should... probably test that we set things up properly? The devil's always in the details when it comes to CI, but we can do some initial checking of things with the <a href="./cli.html#cargo-dist-plan">plan</a> command:</p>
<pre><code class="language-sh">cargo dist plan
</code></pre>
<p><a href="./cli.html#cargo-dist-plan">plan</a> is the same as <a href="./cli.html#cargo-dist-build">build</a> but it doesn't actually <em>run</em> the build and defaults to reporting info for all platforms. This makes it ideal for asking cargo-dist about the full Announcement a CI run would produce.</p>
<p>If everything went right, you should see something like the following:</p>
<p><img src="./img/simple-app-manifest.png" alt="The result of running the plan command, described below" />.</p>
<p>This output has two parts: &quot;analyzing workspace&quot; and &quot;announcing&quot;</p>
<p>&quot;analyzing workspace&quot; describes what cargo-dist found in your workspace. In this case there's a package called &quot;my-app&quot; with a <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries">binary target</a> of the same name.</p>
<p>&quot;announcing v0.1.0&quot; tells us the tag that should be pushed to announce a release of the current workspace (&quot;v0.1.0&quot;). Underneath it we see that the announcement will include &quot;my-app 0.1.0&quot; as expected. Underneath that we see 4 artifacts will be produced and uploaded:</p>
<ul>
<li>The Intel macOS build: my-app-v0.1.0-x86_64-apple-darwin.tar.xz</li>
<li>The M1 macOS build: my-app-v0.1.0-aarch64-apple-darwin.tar.xz</li>
<li>The Windows build: my-app-v0.1.0-x86_64-pc-windows-msvc.zip</li>
<li>The Linux build: my-app-v0.1.0-x86_64-unknown-linux-gnu.tar.xz</li>
</ul>
<p>It also helpfully lists the contents of each zip. In this case I didn't properly setup my project at all, so it only contains a prebuilt binary. If I actually add files like README.md, LICENSE, and RELEASES.md, cargo-dist will helpfully pick those up and include them (disable this with the <code>auto-includes=false</code> <a href="./config.html">config</a>):</p>
<p><img src="./img/simple-app-manifest-with-files.png" alt="The same as the last screenshot, but now the files mentioned above are included in each zip/tarball" />.</p>
<p>If you add <code>--output-format=json</code> you'll get a full machine-readable output instead, and have locally recreated the first step of the generate CI!</p>
<h2 id="cutting-releases"><a class="header" href="#cutting-releases">Cutting Releases</a></h2>
<p>With all our one-time setup done, we're ready to cut a release! This can be streamlined a lot with <a href="https://github.com/crate-ci/cargo-release">cargo-release</a> which will do essentially everything we're about to go through with a single command (<a href="./cargo-release-guide.html">see the guide on that</a>), but it's helpful to understand the actual steps in case cargo-release doesn't fit your usecase or if you need to debug issues.</p>
<p>The first step is to do all the things you would do to prep a release: update docs, update release notes, bump version numbers in Cargo.tomls, run tests, and so on.</p>
<p>At this point we're confident and want to release things for real. Once again, we can check what cargo-dist thinks should happen with the <a href="./cli.html#cargo-dist-plan">plan</a> command:</p>
<pre><code class="language-sh">cargo dist plan
</code></pre>
<p>Similarly you can check that <code>cargo publish</code> will work with the <code>--dry-run</code> flag:</p>
<pre><code class="language-sh">cargo publish --dry-run
</code></pre>
<p>If both of those seem happy, you're ready to release! All we need to do is push up a commit that has the <a href="https://git-scm.com/book/en/v2/Git-Basics-Tagging">Git Tag</a> that <a href="./cli.html#cargo-dist-plan">plan</a> suggested. As we've seen in previous sections, it's recommending &quot;v0.1.0&quot; for our example app, so let's use that:</p>
<pre><code class="language-sh"># Publish to a Github Release with cargo-dist
git commit -am &quot;Chore: Release 0.1.0&quot;
git tag &quot;v0.1.0&quot;
git push
git push --tags

# Publish to crates.io
cargo publish
</code></pre>
<p>and that's... it! If everything's working, your CI should spin up a &quot;Release&quot; workflow that cargo-dist generated for you, and after a few minutes the &quot;Releases&quot; section of your repo should have all the results populated with something like this:</p>
<p><img src="./img/simple-github-release.png" alt="A Github Release for &quot;my-app 0.1.0&quot; with shell-script installers and tarballs of prebuilt binaries" /></p>
<p>Oops! There's some extra features in that screenshot that I haven't explained yet! This includes the &quot;Release Notes&quot; feature and a few <a href="./installers.html">installers</a>. Since we're talking about Releasing, let's talk about Release Notes.</p>
<h3 id="release-notes"><a class="header" href="#release-notes">Release Notes</a></h3>
<p>If your project has a top-level RELEASES/CHANGELOG file like &quot;RELEASES.md&quot;, then cargo-dist will automatically try to use it as part of your Announcement (Github Release). We use the <a href="https://github.com/taiki-e/parse-changelog">parse-changelog</a> library to try to find a heading for the version you're releasing, and if we do, we add it to the Github Release's text. We also use the heading as the title for the Github Release (rather than just the git tag).</p>
<p>Roughly speaking, the library is looking for something like: </p>
<pre><code class="language-text"># &lt;ignorable prefix&gt; &lt;version&gt; &lt;ignorable suffix&gt;
</code></pre>
<p>For instance in <code># Version 1.0.0 (2022-03-01)</code>, the only really important part is the &quot;1.0.0&quot;, which should exactly match the Cargo version of your package. If you want to see how your RELEASES/CHANGELOG file is interpreted you can install parse-changelog as a CLI and run it on the file to see what it thinks. In the future we'll have some better debugging tools for this.</p>
<p>If you're publishing a Version with some prerelease bits like &quot;1.0.0-prerelease.1&quot;, then we'll first look for that exact match in your RELEASES/CHANGELOG. If we can't find it we'll strip the prerelease/build suffix (in this case going back to &quot;1.0.0&quot;) and check for that. If <em>that</em> finds a match we'll edit the heading to include the prerelease suffix when we include it in the Announcement. This lets you have a stable heading like <code># Version 1.0.0 (under development)</code>, and prereleases will get headings like <code># Version 1.0.0-prerelease.1 (under development)</code>.</p>
<p>If none of the previous rules apply, &quot;1.0.0-prerelease.1&quot; will also match a special &quot;Unreleased&quot; heading (i.e. &quot;# Unreleased&quot;), which will get rewritten to &quot;# Version 1.0.0-prerelease.1&quot;. This lets you maintain a changelog for a pending release without having to commit to what version it will be.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guide-more-complex-workspaces"><a class="header" href="#guide-more-complex-workspaces">Guide: More Complex Workspaces</a></h1>
<ul>
<li><a href="workspace-guide.html#multiple-binaries-in-one-package">Multiple Binaries In One Package</a></li>
<li><a href="workspace-guide.html#multiple-packages-in-a-workspace">Multiple Packages In A Workspace</a></li>
<li><a href="workspace-guide.html#announcement-tags">Announcement Tags</a></li>
<li><a href="workspace-guide.html#singular-library-hack">Singular Library Hack</a></li>
<li><a href="workspace-guide.html#using-cargo-release">Using cargo-release</a></li>
</ul>
<p>Now that we've <a href="./simple-guide.html">looked at a simple example</a> with <code>cargo new</code>, let's start looking at ways to make a <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">Cargo Workspace</a> more complicated, and how cargo-dist will deal with them.</p>
<p>But first, let's define some precise terminology: </p>
<p>Rust projects typically exist as a single <em><a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">Workspace</a></em>, which is a collection of one or more <em><a href="https://doc.rust-lang.org/cargo/appendix/glossary.html#package">Packages</a></em> that are all developed in the same repository (<a href="https://crates.io/">crates.io</a> dependencies are not considered part of the workspace). A workspace always has a root Cargo.toml where certain workspace-global settings are defined. </p>
<p>If the root Cargo.toml <em>doesn't</em> define a Package then we say it's a <em><a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#virtual-workspace">Virtual Workspace</a></em>. A Virtual Workspace puts all the packages on the same level, treating them as equals. If you don't use a Virtual Workspace you are essentially saying the entire project exists to produce that one root Package. Both approaches make sense in different contexts. I personally prefer virtual workspaces because it makes cargo (and other tools) default to operating on all packages at once, which is usually what I want (e.g. I want <code>cargo test</code> to test the entire workspace, I want <code>cargo fmt</code> to format the whole workspace, and so on).</p>
<p>A <em><a href="https://doc.rust-lang.org/cargo/appendix/glossary.html#package">Package</a></em> is the thing defined by a Cargo.toml (except for the root Cargo.toml of a Virtual Workspace, which defines no package). Many people reasonably assume &quot;Package&quot; and &quot;Crate&quot; are synonyms -- after all you host your Packages on a website called &quot;<a href="https://crates.io/">crates.io</a>&quot;! As it turns out, this is not the case: a Package can in fact define multiple Crates at the same time.</p>
<p>A <em><a href="https://doc.rust-lang.org/book/ch07-01-packages-and-crates.html">Crate</a></em> is the actual unit of compilation that <em>rustc</em> thinks about, like a single library or binary. For the purposes of cargo-dist, you don't really need a perfect understanding of what is or isn't a &quot;crate&quot;. The important takeaway is that a single Package can contain multiple things that are conflated with a single unified name and version. As we'll see, this can be useful.</p>
<h2 id="multiple-binaries-in-one-package"><a class="header" href="#multiple-binaries-in-one-package">Multiple Binaries In One Package</a></h2>
<p>So here's where the difference between a &quot;Package&quot; and a &quot;Crate&quot; is most relevant: <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries">Cargo lets a single Package define multiple binaries</a>. See those docs for all the details. This can be convenient if you want to produce a single logical application that provides a suite of CLIs. For instance, you might want to make a standalone &quot;my-tool&quot; CLI that can be invoked as <code>cargo my-tool</code> as well. The easiest way to do this is to define a second &quot;cargo-my-tool&quot; binary as part of the &quot;my-tool&quot; Package. Once you do, <code>cargo install my-tool</code> will install both!</p>
<p>cargo-dist tries to respect this semantic. If you define multiple binaries in a Package, we will treat the Package as one &quot;Application&quot; and bundle both binaries in all zips and <a href="./installers.html">installers</a> for that App. There is no way to override this behaviour -- if you don't want two binaries to be considered part of the same App, you should use separate Packages.</p>
<h2 id="multiple-packages-in-a-workspace"><a class="header" href="#multiple-packages-in-a-workspace">Multiple Packages In A Workspace</a></h2>
<p>Alright here's where things get a bit more complicated and you need to make a decision on how exactly you plan to develop and release the packages that make up your project. Up until now we've been assuming you have a single package in your workspace, but now we're going to deal with more.</p>
<p>How cargo-dist interprets multiple packages is actually fairly simple:</p>
<ul>
<li>Each Package that defines binaries is considered an &quot;App&quot; with completely independent zips/installers</li>
<li>Each Package that doesn't define binaries is wholly irrelevant and ignored</li>
</ul>
<p>If a Package defines binaries but you want cargo-dist to ignore it just like it does with library-only packages (i.e. because the binaries are for local testing), you can do that with either:</p>
<ul>
<li><a href="./config.html#publish"><code>publish = false</code> in that Package's Cargo.toml</a></li>
<li><a href="./config.html#dist"><code>dist = false</code> in that Package's <code>[package.metadata.dist]</code></a></li>
</ul>
<p>Now here's the really important question you need to answer: <strong>how do you want to announce new versions of your packages?</strong></p>
<h2 id="announcement-tags"><a class="header" href="#announcement-tags">Announcement Tags</a></h2>
<blockquote>
<p>See <a href="./cargo-release-guide.html">the guide on using cargo-dist with cargo-release for more detailed documentation of how to tag your commits in various workspace configurations</a>!</p>
</blockquote>
<p>When you push a Git Tag to your repository, cargo-dist's CI will try to create a single Announcement (A Github Release) for that tag. When you only have one Package that's a completely unambiguous operation. When you have multiple Packages we now need some way to disambiguate what you actually meant.</p>
<p>1 Git Tag = 1 cargo-dist Announcement = 1 Github Release</p>
<p>cargo-dist supports two forms of Announcement which you can select with the format of your Git Tag:</p>
<ul>
<li>Unified Announcement: <code>v{VERSION}</code> selects all packages with the given version (v1.0.0, v0.1.0-prerelease, ...)</li>
<li>Singular Announcement: <code>{PACKAGE-NAME}-v{VERSION}</code> selects only the given package (my-app-v1.0.0, my-app-v1.0.0-prerelease, ...)</li>
</ul>
<p>These two modes support the following workflows:</p>
<ul>
<li>Releasing a workspace with only one App (either mode works but Unified is Best)</li>
<li>Releasing a workspace where all Apps are versioned in lockstep (Unified)</li>
<li>Releasing an individual App in a workspace with its own independent versioning (Singular)</li>
<li>Releasing several Apps in a workspace at once, but all independently (Push multiple Singular tags at once)</li>
</ul>
<blockquote>
<p>NOTE: Although you <em>could</em> use extremely careful versioning in conjunction with Unified Announcements to release a weird subset of the packages in your workspace, you really <em>shouldn't</em> because the Github Releases will be incoherent (v0.1.0 has these random packages, v0.2.0 has these other random packages... huh?), and you're liable to create painful tag collisions.</p>
</blockquote>
<p><strong>The need for a coherent Announcement Tag is so important that cargo-dist commands like &quot;build&quot; and &quot;manifest&quot; will error out if one isn't provided and it can't be guessed.</strong> If that happens you may need to pass an explicit <code>--tag=...</code> flag to disambiguate. Being this strict helps catch problems before you push to CI.</p>
<h2 id="singular-library-hack"><a class="header" href="#singular-library-hack">Singular Library Hack</a></h2>
<p>Normally cargo-dist will error out if the Announcement Tag selects no Apps, because it exists to build and distribute Apps and you just asked it to do nothing (which is probably a mistake). This would however create annoying CI errors if you just wanted to tag releases for your libraries.</p>
<p>For 0.0.3 I opted for this kind of weird half-functionality:</p>
<p><strong>cargo-dist will produce a very minimal build-less Announcement (and therefore Github Release) if you explicitly request a Singular Announcement that matches a library-only package</strong>. This feature is kind of half-baked, please let us know what you want to happen in this situation!</p>
<p>We'll probably have to add a config for specifying whether you want libraries to get Announcements or not when you push a singular tag for them.</p>
<h2 id="using-cargo-release"><a class="header" href="#using-cargo-release">Using cargo-release</a></h2>
<p>See <a href="./cargo-release-guide.html">the dedicated guide to using cargo-release with cargo-dist</a>, which covers all sorts of nasty workspaces (it's also just a more useful in-depth look at ).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-cargo-release-1"><a class="header" href="#using-cargo-release-1">Using cargo-release</a></h1>
<ul>
<li><a href="cargo-release-guide.html#cargo-release-basics">cargo-release Basics</a></li>
<li><a href="cargo-release-guide.html#cargo-release-advanced-usage">cargo-release Advanced Usage</a></li>
<li><a href="cargo-release-guide.html#one-package">One Package</a></li>
<li><a href="cargo-release-guide.html#virtual-workspace-with-independent-versions">Virtual Workspace With Independent Versions</a></li>
<li><a href="cargo-release-guide.html#virtual-workspace-with-unified-versions">Virtual Workspace With Unified Versions</a></li>
<li><a href="cargo-release-guide.html#non-virtual-workspace-with-unified-versions">Non-Virtual Workspace With Unified Versions</a></li>
<li><a href="cargo-release-guide.html#non-virtual-workspace-with-totally-independent-versions">Non-Virtual Workspace With Totally Independent Versions</a></li>
<li><a href="cargo-release-guide.html#non-virtual-workspace-with-independent-libraries">Non-Virtual Workspace With Independent Libraries</a></li>
<li><a href="cargo-release-guide.html#library-only-workspaces">Library-only Workspaces</a></li>
<li><a href="cargo-release-guide.html#previewing-your-release">Previewing Your Release</a></li>
<li><a href="cargo-release-guide.html#using-cargo-release-with-pull-requests">Using cargo-release with Pull Requests</a></li>
</ul>
<blockquote>
<p>NOTE: It will be helpful to read <a href="./workspace-guide.html#announcement-tags">the section on cargo-dist Announcement Tags</a>, because that is the interface boundary between cargo-release and cargo-dist. TL;DR: cargo-dist interprets a git tag of &quot;v1.0.0&quot; as &quot;Announce/Release the whole workspace&quot; (Unified Announcement) and &quot;my-app-v1.0.0&quot; as &quot;Announce/Release that one package&quot; (Singular Announcement).</p>
</blockquote>
<blockquote>
<p>NOTE: this guide assumes you're running <a href="https://github.com/crate-ci/cargo-release/releases/tag/v0.22.0">cargo-release v0.22.0</a> or greater, as that version made several significant changes to default behaviours (for the better!).</p>
</blockquote>
<p>cargo-dist intentionally doesn't handle these steps of cutting a release for you:</p>
<ul>
<li>updating the versions of your packages</li>
<li>writing your release notes</li>
<li>committing the results</li>
<li>tagging your commits</li>
<li>pushing to your repo</li>
<li>publishing to crates.io</li>
</ul>
<p>There's a lot of different workflows for these things and we're happy to leave that to you. All cargo-dist cares about is that a tagged commit eventually ends up in your repo (and that the format of that commit reflects the versions/names in your Cargo.tomls).</p>
<p>That said, you might find <a href="https://github.com/crate-ci/cargo-release">cargo-release</a> useful because it can handle all of the above things for you in a single command like <code>cargo release 1.0.0</code>. This section is dedicated to explaining how to use cargo-release with cargo-dist in various situations.</p>
<h2 id="cargo-release-basics"><a class="header" href="#cargo-release-basics">cargo-release Basics</a></h2>
<blockquote>
<p>NOTE: cargo-release will never do anything side-effectful unless you also pass it <code>--execute</code>. Unless otherwise specified, we are discussing the behaviour when that flag is passed, but will be omitting it for safety/brevity.</p>
</blockquote>
<p>In <a href="./simple-guide.html">a simple project</a> with one package, without any configuration set for cargo-release, the command <code>cargo release 1.0.0</code> is roughly sugar for:</p>
<pre><code class="language-sh">&lt;does some basic checks for uncommitted files and upstream being ahead&gt;
&lt;edits your Cargo.toml to have version 1.0.0&gt;
git commit -am &quot;chore: Release my-app version 1.0.0&quot;
git tag v1.0.0
cargo publish
git push --atomic &lt;remote-branch&gt; refs/tags/v1.0.0
</code></pre>
<p>(The <code>git push --atomic</code> is basically a more robust version of <code>git push &amp;&amp; git push --tags</code>)</p>
<p>Hey neat that's basically everything I listed at the start of this section! And the tag format is exactly what cargo-dist expects for <a href="./simple-guide.html">a simple project</a>!! What a coincidence!!! 😸</p>
<p>If you don't want some of these behaviours, you can disable them permanently with <code>[workspace.metadata.release]</code> in your Cargo.toml, or disable temporarily with CLI flags. See the <a href="https://github.com/crate-ci/cargo-release/blob/master/docs/reference.md">cargo-release reference</a> for all the details but here's some important ones to only get a subset of the behaviours:</p>
<ul>
<li>Don't want to publish? Set <code>publish = false</code> in the config or pass <code>--no-publish</code> </li>
<li>Don't want to push? Set <code>push = false</code> in the config or pass <code>--no-push</code></li>
<li>Don't want to tag? Set <code>tag = false</code> in the config or pass <code>--no-tag</code></li>
</ul>
<p>See <a href="cargo-release-guide.html#using-cargo-release-with-pull-requests">this section for specific details on using cargo-release with github pull requests (PRs)</a>.</p>
<p>Note also that you can use <code>[package.metadata.release]</code> to set configs on individual packages and not the whole workspace.</p>
<h2 id="cargo-release-advanced-usage"><a class="header" href="#cargo-release-advanced-usage">cargo-release Advanced Usage</a></h2>
<p>With <a href="./workspace-guide.html">a more complex project/workspace</a>, cargo-release won't work as well out of the box with cargo-dist. To understand why, we need to understand the rules it applies consistently that can be strange if unexpected.</p>
<p>When you run <code>cargo release</code> <strong>it should follow the same rules cargo does for selecting the subset of the workspace to operate on</strong>. That is, if you were to run <code>cargo test</code>, the packages that actually get tested are the same ones that <code>cargo release</code> will attempt to release! I'll try to briefly summarize (imperfectly, workspaces can get really Complicated):</p>
<ul>
<li>When run in the subdirectory of a package, execution is scoped to that package</li>
<li>When run in the root of a <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#virtual-workspace">virtual workspace</a> (where the root Cargo.toml isn't an actual package), execution applies to all packages</li>
<li>When run in the root of a non-virtual workspace (where the root Cargo.toml is probably the &quot;main&quot; package that all other packages exist to implement), execution <strong>only applies to the root package</strong>.</li>
<li>When run with <code>--workspace</code>, execution applies to all packages (good for making a non-virtual workspace behave more like a virtual one).</li>
<li>Specific packages can be selected with <code>-p</code>/<code>--package</code></li>
<li>I haven't checked if cargo-release respects <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#the-default-members-field">default-members</a> but that's a thing too!</li>
</ul>
<p><strong>By default, cargo-release will create a separate git tag for every package it's releasing.</strong> The default format of these tags depends on the shape of your workspace:</p>
<ul>
<li>If there is a root package (the workspace is non-virtual), releases of the root package will be tagged as <code>v{VERSION}</code> (&quot;v1.0.0&quot;).</li>
<li>All other packages will be tagged <code>{PACKAGE_NAME}-v{VERSION}</code> (&quot;my-app-v1.0.0&quot;)</li>
</ul>
<p>As we'll see below, these combined behaviours have the following interactions with cargo-dist:</p>
<ul>
<li>✅ one package workspace: tags it like &quot;v1.0.0&quot;</li>
<li>✅ virtual workspace, independent versions: tags each package like &quot;my-app-v1.0.0&quot;</li>
<li>❌ virtual workspace, unified versions: we want a single tag like &quot;v1.0.0&quot;</li>
<li>❌ non-virtual workspace: it will mix the tag formats, which <em>might</em> be ok in one situation</li>
</ul>
<p>Now let's dig into each of these situations in more detail.</p>
<h2 id="one-package"><a class="header" href="#one-package">One Package</a></h2>
<p>TLDR: cargo-release Just Works.</p>
<pre><code class="language-sh">cargo release 1.0.0
</code></pre>
<hr />
<p>As stated previously, cargo-release works great with cargo-dist if you have <a href="./simple-guide.html">a simple project</a> consisting of a single package (the kind of project <code>cargo new my-app</code> or <code>cargo init my-app</code> will create).</p>
<p>See the previous sections for what this will do and how to configure the behaviour if, e.g. you want to hold off on publishing to crates.io or pushing.</p>
<p>The more general version of this situation -- where you have one root package and all the other workspace members are libraries that exist to implement it -- has two possible solutions depending on how you want to version/release the libraries:</p>
<ul>
<li><a href="cargo-release-guide.html#non-virtual-workspace-with-unified-versions">version/release the libraries in lockstep</a></li>
<li><a href="cargo-release-guide.html#non-virtual-workspace-with-independent-libraries">version/release the libraries separately</a></li>
</ul>
<h2 id="virtual-workspace-with-independent-versions"><a class="header" href="#virtual-workspace-with-independent-versions">Virtual Workspace With Independent Versions</a></h2>
<p>TLDR: cargo-release just needs you to specify which package to release.</p>
<pre><code class="language-sh">cargo release -p my-package 1.0.0
</code></pre>
<hr />
<p>If you have a <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#virtual-workspace">virtual workspace</a> (one where the root Cargo.toml isn't an actual package) and want everything in the workspace to be versioned/released independently, then cargo-dist will default to operating on all your packages at once, and you should do the same thing you would do if you were running <code>cargo publish</code>: either use <code>-p</code> to select the relevant packages or <code>cd</code> into the subdir of that package before running the command.</p>
<p>Each tag will induce cargo-dist to produce an independent Announcement (Github Release) for that package. </p>
<p>If the package is a library the Github Release won't have any builds/artifacts uploaded. <a href="./workspace-guide.html#singular-library-hack">See here for details</a>.</p>
<p>Note that we currently don't support finding/emitting Release Notes for Singular Releases (simply haven't had time to design and implement it yet).</p>
<h2 id="virtual-workspace-with-unified-versions"><a class="header" href="#virtual-workspace-with-unified-versions">Virtual Workspace With Unified Versions</a></h2>
<p>TLDR: cargo-release just needs you to specify that versioning/tagging should be unified.</p>
<pre><code class="language-toml"># Add this config to your root Cargo.toml (virtual manifest)
[workspace.metadata.release]
shared-version = true
tag-name = &quot;v{{version}}&quot;
</code></pre>
<pre><code class="language-sh">cargo release 1.0.0
</code></pre>
<hr />
<p>If you have a <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#virtual-workspace">virtual workspace</a> (one where the root Cargo.toml isn't an actual package) and want everything in the workspace to be versioned/released in lockstep with a single Unified Announcement (One Big Github Release), then you're going to need to configure cargo-release as above. </p>
<p>After that it works perfectly, and cargo-release will even automagically handle publishing your packages to crates.io in the right sequence and waiting for the publishes to propagate before running the next one (no more &quot;oops sorry the package you just published isn't actually propagated to the registry yet so the package that depends on it can't be published&quot;).</p>
<p>(See the next section on non-virtual workspaces with unified versions for some grittier details on what's going on here.)</p>
<h2 id="non-virtual-workspace-with-unified-versions"><a class="header" href="#non-virtual-workspace-with-unified-versions">Non-Virtual Workspace With Unified Versions</a></h2>
<p>TLDR: this is much the same as the virtual workspace case <strong>but you need to pass --workspace on the CLI</strong>.</p>
<pre><code class="language-toml"># Add this config to your root Cargo.toml (virtual manifest)
[workspace.metadata.release]
shared-version = true
tag-name = &quot;v{{version}}&quot;
</code></pre>
<pre><code class="language-sh">cargo release 1.0.0 --workspace
</code></pre>
<hr />
<p>If you have a non-virtual workspace (one where the root Cargo.toml is a package) and want everything in the workspace to be versioned/released in lockstep with a single Unified Announcement (One Big Github Release), then it's <em>almost</em> the same as the virtual case (see the previous section).</p>
<p>The one caveat is that cargo-dist is consistent to a fault here, and even though we've explicitly told it things should be versioned/tagged in lockstep, <strong>running it in the root of your project still only releases the root package</strong>, and that's not what you want!</p>
<p>We need to tell it that we <em>really</em> meant it and pass <code>--workspace</code>!</p>
<p>What's happening here is that <code>cargo-release</code> is conceptually defined to run on each package individually, with just the &quot;git push&quot; step being unified. The tagging settings we're providing work because it's basically repeatedly going &quot;oh hey I was already going to make that tag, no need to make it again&quot;. It doesn't have a proper notion of the entire workspace being released in perfect lockstep, so if you ask it to release only some of the packages it will happily oblige.</p>
<p>In the virtual workspace this Just Works because commands in the root directory are implicitly <code>--workspace</code>.</p>
<h2 id="non-virtual-workspace-with-totally-independent-versions"><a class="header" href="#non-virtual-workspace-with-totally-independent-versions">Non-Virtual Workspace With Totally Independent Versions</a></h2>
<p>TLDR: this is a more complicated mess because but you <em>probably</em> want to make the root package have the Singular Announcement format, and then you just need to be explicit about each package you want to release on the CLI:</p>
<pre><code class="language-toml"># Add this config to your root Cargo.toml (main package)
[package.metadata.release]
tag-name = &quot;{{crate_name}}-v{{version}}&quot;
</code></pre>
<pre><code class="language-sh">cargo release -p my-package 1.0.0
</code></pre>
<hr />
<p>If you have a non-virtual workspace (one where the root Cargo.toml is a package) and want everything in the workspace to be versioned/released independently, then the simplest approach is to make everything behave like it does in the <a href="cargo-release-guide.html#virtual-workspace-with-independent-versions">Virtual Workspace With Independent Versions</a>.</p>
<p>However if you find yourself in this position it's likely that your workspace actually looks like:</p>
<ul>
<li>root package is The One Application this project exists to develop</li>
<li>all other packages are libraries that support it</li>
</ul>
<p>In this <em>precise</em> configuration you may be able to avoid configuration by adopting a hybrid &quot;Partially Independent Versions&quot; approach as described in the next section.</p>
<h2 id="non-virtual-workspace-with-independent-libraries"><a class="header" href="#non-virtual-workspace-with-independent-libraries">Non-Virtual Workspace With Independent Libraries</a></h2>
<p>TLDR: technically this Just Works but you need to be specific about what packages you're publishing and may have annoying issues in the future.</p>
<pre><code class="language-sh">cargo release -p my-package 1.0.0
</code></pre>
<hr />
<p>So if your workspace looks like this:</p>
<ul>
<li>root package is The One Application this project exists to develop</li>
<li>all other packages are libraries that support it</li>
</ul>
<p>Whenever you <code>cargo release</code> the root package, it will get tagged without a prefix (&quot;v1.0.0&quot;) and cargo-dist will create a Unified Announcement. Even though there are other packages in the workspace, cargo-dist will take this in stride because as far as it's concerned <strong>this looks exactly the same as a workspace with one package</strong>. Which is to say, it's no different from <a href="./simple-guide.html">a simple project</a> as far as cargo-dist is concerned.</p>
<p>Whenever you <code>cargo release</code> a library, it will get tagged with a prefix (&quot;my-lib-v1.0.0&quot;) and cargo-dist will create a minimal Singular Announcement. <a href="./workspace-guide.html#singular-library-hack">See here for details</a>. In future versions we might change this default (or at least make it configurable).</p>
<p>I have some vague concerns that this will be wonky if you ever introduce a second application to the workspace, but honestly that's probably going to be true regardless of if you were using cargo-dist, so maybe it's fine? Really I just don't trust non-virtual workspaces...</p>
<h2 id="library-only-workspaces"><a class="header" href="#library-only-workspaces">Library-only Workspaces</a></h2>
<p>cargo-dist really isn't designed for this but technically you can use the <a href="./workspace-guide.html#singular-library-hack">Singular Library Trick</a> if you want. If you want cargo-dist to properly support this, please let us know!</p>
<h2 id="previewing-your-release"><a class="header" href="#previewing-your-release">Previewing Your Release</a></h2>
<p>cargo-release defaults to dry-run semantics, only doing side-effectful operations if you pass it <code>--execute</code>. It will also do its best to detect problems early and error out if things seem wrong. This absolutely rules! </p>
<p>There are two things to keep in mind: </p>
<ul>
<li>cargo-release's dry-run is imperfect and has some differences from the real run</li>
<li>cargo-release isn't aware of cargo-dist, so it can't check if what it's about to do will blow up in CI or not</li>
</ul>
<p>Let's start with the dry-run differences. I don't know them all but the <em>biggest</em> one that I hit is that it doesn't fully emulate bumping the versions in your Cargo.tomls. Notably when it checks if <code>publish</code> will work, it's building the current version of the packages. If your build is aware of its own version this can cause/miss problems (and you'll see funky stuff like &quot;Upgrading my-app from 1.0.0 to 2.0.0&quot; ... &quot;Packaging my-app 1.0.0&quot;).</p>
<p>As for being aware of cargo-dist... I want to design some features for this, but I'm not quite sure what it should look like yet.</p>
<p>I think in the short-term, the best I can offer you is &quot;make a temporary git branch and tell cargo-release to --execute but not push/tag/publish, then ask cargo-dist what it thinks extremely manually&quot;. A rough sketch:</p>
<pre><code class="language-sh"># make a temp branch where we can mess stuff up
git checkout -b tmp-release

# ask cargo-release what it thinks should happen
# (substitute the actual cargo-release command you'd use here)
cargo release 1.0.0
</code></pre>
<p>That should end with a line that looks like &quot;Pushing main, v1.0.0 to origin&quot;. The first item is the branch it's pushing to, all the following items are all the tags it wants to push. Now that we know the tags, we can ask cargo-release to update the package versions and then ask cargo-dist what it thinks of those tags:</p>
<pre><code class="language-sh"># just bump versions
cargo release 1.0.0 --execute --no-push --no-tag --no-publish

# ask cargo-dist what should be produced for the given tag
cargo dist plan --tag=&lt;tag-you-want-to-check&gt;
</code></pre>
<p>If that runs successfully and prints out the artifacts you expect, that's pretty good sign running cargo-release For Real will work! (You can also try <code>cargo dist build</code> if you're worried about the actual build failing.)</p>
<h2 id="using-cargo-release-with-pull-requests"><a class="header" href="#using-cargo-release-with-pull-requests">Using cargo-release with Pull Requests</a></h2>
<blockquote>
<p>In this section we will be using <code>$BRANCH</code> and <code>$VERSION</code> as placeholders for the branch you make your PR on and the version you want to release.</p>
</blockquote>
<p>Many teams have policies that prevent pushing to main, and require you to open pull requests instead. This conflicts with the <em>default</em> behaviour of cargo-release, but it works fine with some extra flags to encourage it to defer the steps until later. Specifically, use the following to &quot;partially&quot; run cargo-release:</p>
<pre><code class="language-sh">cargo release --no-publish --no-tag --allow-branch=$BRANCH $VERSION
</code></pre>
<p>The release process then has the following steps:</p>
<ul>
<li>step 0: create a new branch for the PR</li>
<li>step 1: &lt; finalize things like changelogs and commit &gt;</li>
<li>step 2: <strong>partially</strong> run <code>cargo release ...</code> to update your Cargo.tomls and push your branch</li>
<li>step 3: &lt; open a pr, review, merge &gt;</li>
<li>step 4: <strong>fully</strong> run <code>cargo release</code> on main to complete the process (publish and tag)</li>
</ul>
<p>Crucially, neither invocation of <code>cargo release</code> will modify your main branch directly. Step 4 will only push a git tag for the commit that is already on main.</p>
<p>Here's what this looks in practice:</p>
<pre><code class="language-sh"># step 0: make a branch
git checkout -b $BRANCH


# step 1: update things like the changelog
# &lt; edit some files or whatever here &gt;
git commit -am &quot;prep release&quot;


# step 2: have cargo-release handle tedious mechanical stuff
# this will:
#  * do some safety checks like &quot;git index is clean&quot;
#  * update version numbers in your crates (and handle inter-dependencies)
#  * git commit -am &quot;chore: release $NAME $VERSION&quot; (one commit for the whole workspace)
#  * git push (remember we're on a branch)
cargo release --no-publish --no-tag --allow-branch=$BRANCH $VERSION


# step 3: open a PR and review/merge to main
# NOTE: the above steps will result in two commits
#       we recommend using github's &quot;merge and squash&quot; feature to clean up
# ...


# step 4: remove the shackles from cargo release and RUN ON MAIN
# this will:
#  * tag the commit
#  * push the tag
#  * publish all crates to crates.io (handles waiting for dep publishes to propagate)
#  * trigger cargo-dist when it sees the tag (if applicable)
# THIS WON'T CREATE NEW COMMITS
#
# running &quot;cargo dist plan&quot; is totally optional, but this is is the best time to check
# that your cargo-dist release CI will produce the desired result when you push the tag
git checkout main
git pull
cargo dist plan
cargo release
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<p>The following sections are more focused on precise details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<ul>
<li><a href="concepts.html#defining-your-apps">Defining Your Apps</a></li>
<li><a href="concepts.html#defining-your-artifacts">Defining Your Artifacts</a></li>
<li><a href="concepts.html#announcements-selecting-apps">Announcements (Selecting Apps)</a></li>
<li><a href="concepts.html#artifact-modes-selecting-artifacts">Artifact Modes (Selecting Artifacts)</a>
<ul>
<li><a href="concepts.html#all-artifacts-mode">All Artifacts Mode</a></li>
<li><a href="concepts.html#global-artifacts-mode">Global Artifacts Mode</a></li>
<li><a href="concepts.html#local-artifacts-mode">Local Artifacts Mode</a></li>
<li><a href="concepts.html#host-artifacts-mode">Host Artifacts Mode</a></li>
</ul>
</li>
<li><a href="concepts.html#putting-it-all-together">Putting It All Together</a></li>
</ul>
<p>Here's the section where I use a bunch of words Capitalized Words to indicate they are a Special Concept in cargo-dist as I try to explain how it works. These are the &quot;advanced&quot; docs of cargo-dist, for the &quot;beginner&quot; docs see <a href="./guide.html">the guide</a> for the &quot;beginner&quot; docs.</p>
<p>An invocation of cargo-dist has 4 major inputs:</p>
<ul>
<li>The structure of your project's <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">Cargo Workspace</a> (via <a href="https://doc.rust-lang.org/cargo/commands/cargo-metadata.html">cargo-metadata</a>)</li>
<li>The config in your Cargo.toml <code>[workspace.metadata.dist]</code> (and <code>[package.metadata.dist]</code>)</li>
<li>The &quot;announcement tag&quot; (e.g. <code>--tag=v1.0.0</code>) </li>
<li>The &quot;artifact mode&quot; (e.g. <code>--artifacts=all</code>)</li>
</ul>
<p>The first two define the full &quot;Universe&quot; of your project -- the platforms/binaries/<a href="./installers.html">installers</a> that cargo-dist wants to build. The second two tell cargo-dist what subset of the Universe to actually bother with.</p>
<p>It's important to the structure of cargo-dist that every invocation is aware of the full Universe and how it's being subsetted, because for instance if you want a shell script installer that does platform detection and fetches binaries, it needs to know about all the binaries/platforms it has to select from, even if this <em>particular</em> run of cargo-dist won't build them all!</p>
<p>First let's look at how cargo-dist computes the Universe.</p>
<h1 id="defining-your-apps"><a class="header" href="#defining-your-apps">Defining Your Apps</a></h1>
<p>Each Cargo package in your workspace that has <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries">binary targets</a> is considered an App by cargo-dist. cargo-dist exists to build Apps, so making sure you and it agree on is important! (We prefer &quot;App&quot; over &quot;package&quot; because we want the freedom to one day decouple the two concepts -- for now they are strictly equivalent.)</p>
<p>Most invocations of cargo-dist will start by printing out a brief summary of the Apps that cargo-dist has found:</p>
<p><img src="img/workspace-log.png" alt="screenshot of the debug log, described below" /></p>
<p>The summary includes a list of every package in your workspace. If that package defines binaries, they will be listed underneath the package. If the package's listing is greyed out, that means cargo-dist has decided it's either Not An App or that it's not part of the current Announcement (<a href="concepts.html#announcements-selecting-apps">see the Announcement section</a>), along with a parenthetical reason for its rejection, such as: &quot;no binaries&quot;, &quot;publish = false&quot;, &quot;dist = false&quot;, or &quot;didn't match tag&quot;.</p>
<p>In the above example the available Apps are &quot;evil-workspace&quot;, &quot;many-bin&quot;, and &quot;third-bin&quot;. &quot;many-bin&quot; defines two binaries, while the other two Apps only define one.</p>
<p>To match cargo-install's behaviour, if a package defines multiple binaries then they will be considered part of the same App and zips/<a href="./installers.html">installers</a> for it will contain/install all of them. We figure if you went out of your way to have multiple binaries under one package (as opposed to separate packages for each), you did that for a reason! If you don't want that, make separate packages. There is currently no way to group multiple packages into a single App, although there probably will be one day.</p>
<p>If you don't want a package-with-binaries to be considered an App that cargo-dist should care about, you can use Cargo's own builtin <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-publish-field">publish = false</a>. You can also use <code>dist = false</code> or <code>dist = true</code> in <a href="./config.html#dist">cargo-dist's own config</a>, which when defined will take priority over <code>publish</code>.</p>
<p>Things like <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#library">cdylibs</a> are not picked up by cargo-dist, even though they're similar to binaries. If anyone has a usecase for this we're happy to consider it (<a href="https://github.com/rust-lang/cargo/issues/6313">although there's some messy issues around Cargo clobbering itself when you define two many things under one package</a>).</p>
<h1 id="defining-your-artifacts"><a class="header" href="#defining-your-artifacts">Defining Your Artifacts</a></h1>
<p>Ok so you've defined your App, but what should we actually build for it? Let's look at what <code>cargo dist init --ci=github --installer=shell --installer=powershell --yes</code> dumps into your root Cargo.toml:</p>
<pre><code class="language-toml"># Config for 'cargo dist'
[workspace.metadata.dist]
# The preferred cargo-dist version to use in CI (Cargo.toml SemVer syntax)
cargo-dist-version = &quot;0.0.3&quot;
# The preferred Rust toolchain to use in CI (rustup toolchain syntax)
rust-toolchain-version = &quot;1.67.1&quot;
# CI backends to support (see 'cargo dist generate-ci')
ci = [&quot;github&quot;]
# The installers to generate for each app
installers = [&quot;shell&quot;, &quot;powershell&quot;]
# Target platforms to build apps for (Rust target-triple syntax)
targets = [&quot;x86_64-unknown-linux-gnu&quot;, &quot;x86_64-apple-darwin&quot;, &quot;x86_64-pc-windows-msvc&quot;, &quot;aarch64-apple-darwin&quot;]

# The profile that 'cargo dist' will build with
[profile.dist]
inherits = &quot;release&quot;
lto = &quot;thin&quot;
</code></pre>
<p>The parts we're really interested in here are &quot;installers&quot;, &quot;targets&quot;, and <code>[profile.dist]</code>.</p>
<p>First the easy part: <code>profile.dist</code> is the profile cargo-dist will build everything with. We define a separate profile from <code>release</code> so that it can be tuned more aggressively for builds that are longer or more resource-intensive without making it tedious to develop locally.</p>
<p>The other 3 fields are defining the various Artifacts that should be produced for each App in the workspace (because this is <code>[workspace.metadata]</code> and not <code>[package.metadata]</code>). </p>
<p>For each entry in <code>targets</code> you will get a build of your App for <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">that platform</a> in the form of an <a href="./artifacts.html#executable-zip">executable-zip</a>.</p>
<p>For each entry in <code>installers</code> you get that kind of <a href="./installers.html">installer</a> for your App. There are two classes of installer: &quot;global&quot; and &quot;local&quot;. This will be explained further in <a href="concepts.html#artifact-modes-selecting-artifacts">the section on artifact modes</a>, but the tl;dr is that &quot;global&quot; installers are one-per-App while &quot;local&quot; installers are one-per-platform-per-app, similar to a <a href="https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs">Github CI Matrix</a>.</p>
<p>&quot;shell&quot; and &quot;powershell&quot; are both global installers. There aren't currently any implemented local installers, but those would be things like a windows &quot;msi&quot; or macos &quot;dmg&quot;, where you ostensibly want individual installers for each architecture.</p>
<h1 id="announcements-selecting-apps"><a class="header" href="#announcements-selecting-apps">Announcements (Selecting Apps)</a></h1>
<p>cargo-dist's self-generated CI is triggered by pushing git tags with specific formats like &quot;v1.0.0&quot; or &quot;my-app-v1.0.0&quot;. Each tag will trigger its own independent run of that CI workflow. That tag defines the subset of the workspace (what packages) we want to produce a single unified Announcement for (i.e. a single Github Release). Every invocation of cargo-dist in that CI run will be passed that git tag with the <code>--tag</code> flag to ensure consensus on what to Announce (and therefore build and upload).</p>
<p>1 Git Tag = 1 cargo-dist Announcement = 1 Github Release</p>
<p>Even when not running in CI, this concept of a coherent Announcement Tag is important enough that we will always try to guess one even if none is provided. The &quot;build&quot;, &quot;manifest&quot;, and &quot;plan&quot; commands will refuse to run if a coherent Announcement Tag can't be determined to help you catch problems before you start pushing to CI. If this happens you will get a printout telling you some options:</p>
<p><img src="img/announcement-error.png" alt="the error printout, described below" /></p>
<p>Here we have the same workspace we saw in the <a href="concepts.html#defining-your-apps">&quot;defining your apps&quot; section</a>, but we get a complaint from <code>cargo dist manifest</code>:</p>
<blockquote>
<p>There are too many unrelated apps in your workspace to coherently Announce!</p>
<p>Please either specify --tag, or give them all the same version</p>
</blockquote>
<p><strong>This introduces the one big rule for Announcements: all the Apps being Announced together have to agree on their Version.</strong> We need something to tie the announcement together and &quot;3 random Apps with different Versions&quot; has nothing to use! You should really just have 3 separate Announcements for those Apps. If you disagree, please let us know!</p>
<p>The error goes on to recommend the two formats for the Announcement Tag:</p>
<ul>
<li>Unified Announcement: <code>v{VERSION}</code> selects all packages with the given version (v1.0.0, v0.1.0-prerelease, etc.)</li>
<li>Singular Announcement: <code>{PACKAGE-NAME}-v{VERSION}</code> selects only the given package (error if the version doesn't match the Cargo.toml)</li>
</ul>
<p>These two modes support the following workflows:</p>
<ul>
<li>Releasing a workspace with only one App (either mode works but Unified is Cleaner)</li>
<li>Releasing a workspace where all Apps are versioned in lockstep (Unified)</li>
<li>Releasing an individual App in a workspace with its own independent versioning (Singular)</li>
<li>Releasing several Apps in a workspace at once, but all independently (Push multiple Singular tags at once)</li>
</ul>
<p>In this case the error notes two valid Unified Announcements:</p>
<blockquote>
<p><code>--tag=v0.5.0</code> will Announce: evil-workspace, third-bin
<code>--tag=v0.7.6</code> will Announce: many-bin</p>
</blockquote>
<p>This tells us that evil-workspace and third-bin actually already agree on their Version. If we <em>do</em> want a Unified Announcement, we probably want to bring many-bin into agreement, or mark it as publish=false or dist=false.</p>
<p>Although you <em>could</em> use extremely careful versioning in conjunction with Unified Announcements to release a weird subset of the packages in your workspace, you really <em>shouldn't</em> because the Github Releases will be incoherent (v0.1.0 has these random packages, v0.2.0 has these other random packages... huh?), and you're liable to create painful tag collisions.</p>
<p>Normally cargo-dist will error out if the Announcement Tag selects no Apps, because it exists to build and distribute Apps and you just asked it to do nothing (which is probably a mistake). This would however create annoying CI errors if you just wanted to tag Individual Releases for your libraries. To make this more pleasant, <strong>cargo-dist will produce a very minimal build-less Announcement (and therefore Github Release) if you explicitly request a Singular Announcement that matches a library-only package</strong>. This feature is kind of half-baked, please let us know what you want to happen in this situation!</p>
<h1 id="artifact-modes-selecting-artifacts"><a class="header" href="#artifact-modes-selecting-artifacts">Artifact Modes (Selecting Artifacts)</a></h1>
<p>Now that we have a coherent Announcement and therefore have selected what apps we want to Release, we need to select what artifacts we want to build (or get a manifest for). Enumerating the exact artifacts for each invocation of cargo-dist would be tedious and error-prone, so we provide the <code>--artifacts=...</code> flag to specify the <em>Artifact Mode</em>, which is a certain subset of the Universe of all Artifacts:</p>
<ul>
<li>&quot;local&quot;: artifacts that are per-target platform (<a href="./artifacts.html#executable-zip">executable-zips</a>, symbols, MSIs...)</li>
<li>&quot;global&quot;: artifacts that are one-per-app (shell installer, npm package...)</li>
<li>&quot;all&quot;: both global and local (so the whole Universe)</li>
<li>&quot;host&quot;: the default mode that kind of breaks the rules to let you test things out locally</li>
</ul>
<p>Let's ignore &quot;host&quot; mode for a bit and focus on the other three. Each one of these is intended to be used for specific tasks.</p>
<h2 id="all-artifacts-mode"><a class="header" href="#all-artifacts-mode">All Artifacts Mode</a></h2>
<p>The &quot;all&quot; Artifact Mode is largely intended for the <code>manifest</code> command, to get a listing of everything that would be produced if you were to push the given tag to CI. Here we check what v0.5.0 would produce for our favourite example workspace:</p>
<pre><code class="language-sh">cargo dist manifest --tag=v0.5.0 --artifacts=all --no-local-paths
</code></pre>
<p><img src="img/human-manifest-all.png" alt="A listing of the various Artifacts that should be produced" /></p>
<p>If we add <code>--output-format=json</code> we will get the <code>dist-manifest.json</code> that CI uploads to your Github Release:</p>
<pre><code class="language-sh">cargo dist manifest --tag=v0.5.0 --artifacts=all --no-local-paths --output-format=json
</code></pre>
<p>This is the only way that CI uses the flag, but you could also use &quot;all&quot; with <code>build</code> (the default cargo-dist command) if you want to get all the artifacts built at once, although you should probably filter the <code>--target</code>s as discussed in the section on &quot;local&quot;.</p>
<p><code>cargo dist manifest --artifacts=all --no-local-paths</code> is so useful/common that we provide an alias for it: <code>cargo dist plan</code>. The above can be simplified to:</p>
<pre><code class="language-sh">cargo dist plan --tag=v0.5.0
</code></pre>
<pre><code class="language-sh">cargo dist plan --tag=v0.5.0 -ojson
</code></pre>
<h2 id="global-artifacts-mode"><a class="header" href="#global-artifacts-mode">Global Artifacts Mode</a></h2>
<p>The &quot;global&quot; Artifact Mode allows you to unambiguously create a task that will build all the Artifacts for your Apps that <em>aren't</em> platform-specific and therefore only need to be made once per App:</p>
<pre><code class="language-sh">cargo dist build --tag=v0.5.0 --artifacts=global --no-local-paths
</code></pre>
<p><img src="img/global-build.png" alt="A global build producing only shell and powershell installers" /></p>
<p>Here we see that it only results in the &quot;shell&quot; and &quot;powershell&quot; installers getting built. The code to generate these should be totally cross-platform, so any runner is suitable for the task. The CI creates one &quot;global&quot; task that uses linux because that's the fast/cheap one.</p>
<h2 id="local-artifacts-mode"><a class="header" href="#local-artifacts-mode">Local Artifacts Mode</a></h2>
<p>The &quot;local&quot; Artifact Mode allows you to unambiguously create a task that will build all the Artifacts for your Apps that <em>are</em> platform-specific and therefore should have a copy made for every target platform.</p>
<p>If you just use this flag bare, cargo-dist <em>will</em> respect the request and try to build for all platforms at once... and this will probably fail, because cross-compilation is hard. Each &quot;local&quot; run should generally use <code>--target</code> to filter down the set of all supported targets to the ones you can confidently build on the current machine (<code>rustc -vV</code> will tell you the &quot;host&quot; target platform if you're not sure).</p>
<p>In my case it's &quot;x86_64-pc-windows-msvc&quot;, so let's try that:</p>
<pre><code class="language-sh">cargo dist build --tag=v0.5.0 --artifacts=local --target=x86_64-pc-windows-msvc --no-local-paths
</code></pre>
<p><img src="img/local-build.png" alt="A local build producing only executable-zips for the current platform" /></p>
<p>Note that you can pass <code>--target</code> multiple times to select more than one. Note also that <code>--target</code> is not allowed to select targets that aren't specified by the config your Cargo.toml. This ensures that global installers are consistently aware of all the platform-specific artifacts they can fetch. (&quot;host&quot; mode breaks this rule.) ((Also in theory <code>--installer</code> should work the same for selecting specific installers but it's not well tested because there isn't any reason to ever use that outside of <code>cargo dist init</code>.))</p>
<p>CI will spin up one &quot;local&quot; task for each of the major desktop platforms, grouping the targets that are easy to build on those platforms together. In the future we might want to spawn one task per target, or at least make that an option you can pick. That said, some Artifacts like macOS universal binaries may find it useful to have multiple targets built on the same machine!</p>
<h2 id="host-artifacts-mode"><a class="header" href="#host-artifacts-mode">Host Artifacts Mode</a></h2>
<p>Host mode is the default &quot;do something useful on my machine&quot; mode. It's intended for testing and demoing cargo-dist on your project, and is never used in CI due to its intentionally fuzzy semantics.</p>
<p>It's currently roughly equivalent to <code>--artifacts=all --target=HOST_TARGET</code>, but HOST_TARGET is allowed to fall outside the set of targets defined in your Cargo.toml, because it's not terribly useful to tell someone trying out cargo-dist on ARM64 Linux that their platform isn't defined in the config.</p>
<p>In principle when we have better support for cross-compilation we might also try to build &quot;nice&quot; crosses like &quot;intel apple =&gt; arm64 apple&quot;. Do not rely on the behaviour of this mode, always use one of the 3 other modes in your infra/scripts!</p>
<p>If you <em>do</em> pass <code>--target</code> in host mode then we won't do fuzzy target selection and will just build the targets you ask for like normal.</p>
<h1 id="putting-it-all-together"><a class="header" href="#putting-it-all-together">Putting It All Together</a></h1>
<p>Ok so here's what goes through cargo-dist's brains when you run it:</p>
<ol>
<li>Read in the workspace/config/cli-flags</li>
<li>Determine the Announcement Tag (select the Apps) (&quot;v1.0.0&quot;)</li>
<li>Determine what Targets we're building for</li>
<li>Call the specific Version of each App a &quot;Release&quot; (&quot;my-app-v1.0.0&quot;)</li>
<li>For each Release-Target pair, create a &quot;ReleaseVariant&quot; (&quot;my-app-v1.0.0-x86_64-apple-darwin&quot;)</li>
<li>Add executable-zip Artifacts to each Release (broadcasted to each Variant, filtered by Artifact Mode)</li>
<li>Add all the enabled Installers to each Release (local ones broadcasted to each Variant, filtered by Artifact Mode)</li>
<li>Compute the Build Steps necessary to produce each Artifact (&quot;run cargo, copy this file, ...&quot;)</li>
<li>Generate top-level Announcement info like the body for a Github Release</li>
<li>run the Build Steps (ignored by <code>manifest</code>/<code>plan</code>)</li>
<li>print a manifest of the computed Announcement/Releases/Artifacts</li>
</ol>
<p>CI will parse the resulting (<code>--output-format=json</code>) manifest of each <code>build</code> invocation to know what artifacts were produced and need to be uploaded to the Github Release.</p>
<p>CI will just invoke cargo-dist in the following sequence:</p>
<ol>
<li>create-release: <code>cargo dist manifest --artifacts=all --output-format=json --no-local-paths</code></li>
<li>upload-artifacts (local): <code>cargo dist build --artifacts=local --target=... --output-format=json</code></li>
<li>upload-artifacts (global): <code>cargo dist build --artifacts=global --output-format=json</code></li>
<li>publish-release: none, just marks the Github Release as a non-draft</li>
</ol>
<p>(All the upload-artifacts tasks are in parallel, and there are multiple &quot;local&quot; tasks to cover the target platforms.)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="config"><a class="header" href="#config">Config</a></h1>
<ul>
<li><a href="config.html#relevant-cargotoml-fields">Relevant Cargo.toml Fields</a>
<ul>
<li><a href="config.html#name">name</a></li>
<li><a href="config.html#version">version</a></li>
<li><a href="config.html#publish">publish</a></li>
<li><a href="config.html#repository">repository</a></li>
<li><a href="config.html#readme">readme</a></li>
<li><a href="config.html#license-file">license-file</a></li>
</ul>
</li>
<li><a href="config.html#workspacemetadatadist">workspace.metadata.dist</a>
<ul>
<li><a href="config.html#cargo-dist-version">cargo-dist-version</a></li>
<li><a href="config.html#rust-toolchain-version">rust-toolchain-version</a></li>
<li><a href="config.html#ci">ci</a></li>
<li><a href="config.html#targets">targets</a></li>
<li><a href="config.html#installers">installers</a></li>
<li><a href="config.html#include">include</a></li>
<li><a href="config.html#auto-includes">auto-includes</a></li>
<li><a href="config.html#windows-archive">windows-archive</a></li>
<li><a href="config.html#unix-archive">unix-archive</a></li>
<li><a href="config.html#dist">dist</a></li>
<li><a href="config.html#npm-scope">npm-scope</a></li>
<li><a href="config.html#checksum">checksum</a></li>
<li><a href="config.html#precise-builds">precise-builds</a></li>
<li><a href="config.html#merge-tasks">merge-tasks</a></li>
<li><a href="config.html#fail-fast">fail-fast</a></li>
<li><a href="config.html#install-path">install-path</a></li>
</ul>
</li>
<li><a href="config.html#subsetting-ci-flags">Subsetting CI Flags</a></li>
</ul>
<p>cargo-dist accepts configuration from the following sources, in order of increasing preference (that is, CLI flags generally replace things specified in your Cargo.toml):</p>
<ul>
<li>Relevant <a href="https://doc.rust-lang.org/cargo/reference/manifest.html">Cargo.toml fields</a> like &quot;repository&quot; and &quot;readme&quot;</li>
<li><code>[workspace.metadata.dist]</code></li>
<li><code>[package.metadata.dist]</code></li>
<li>CLI flags</li>
</ul>
<p>As discussed in <a href="./concepts.html">concepts</a>, all of your config should be persistently stored in the first 3 locations so that every run of cargo-dist agrees on what &quot;build everything&quot; should look like. CLI flags should primarily be used to select <em>subsets</em> of that &quot;everything&quot; for an individual run of cargo-dist to care about.</p>
<h2 id="relevant-cargotoml-fields"><a class="header" href="#relevant-cargotoml-fields">Relevant Cargo.toml Fields</a></h2>
<p>The <a href="https://doc.rust-lang.org/cargo/reference/manifest.html">builtin Cargo.toml fields</a> define a lot of things that cargo-dist cares about. Here's the ones that matter:</p>
<h3 id="name"><a class="header" href="#name">name</a></h3>
<p>The name of your package will become the name cargo-dist uses to refer to your package. There is currently no notion of a &quot;prettier display name&quot; (if you have a use for that, let us know!).</p>
<h3 id="version"><a class="header" href="#version">version</a></h3>
<p>The version of your package is used pervasively, and cargo-dist will generally error out if you ask it to build &quot;my-app-1.0.0&quot; when the actual &quot;my-app&quot; package is set to version &quot;1.1.0&quot;.</p>
<h3 id="publish"><a class="header" href="#publish">publish</a></h3>
<p>If you set <code>publish = false</code> in your Cargo.toml we will treat this as a hint that cargo-dist should ignore all the affected packages completely. You can override this with dist's own <code>dist = true</code> config.</p>
<h3 id="repository"><a class="header" href="#repository">repository</a></h3>
<p>cargo-dist has an internal notion of an &quot;artifact download URL&quot; that is required for things like <a href="./installers.html">installers</a> that detect the current platform and fetch binaries. If your CI backend is &quot;github&quot; then we will base the &quot;<a href="./installers.html#artifact-download-url">artifact download URL</a>&quot; on the &quot;repository&quot; key. To be safe, we will only do this if your workspace agrees on this value. It's fine if only some packages bother setting &quot;repository&quot;, as long as the ones that do use the exact same string. If they don't we will fail to compute an &quot;artifact download URL&quot;, emit a warning, and ignore your request for installers that require it. (This might want to be a hard error in the future.)</p>
<h3 id="readme"><a class="header" href="#readme">readme</a></h3>
<p>cargo-dist defaults to trying to include certain &quot;important&quot; static files in your executable-zips. A README is one of them.</p>
<p>If you specify a path to a README file, cargo-dist will use that for all the packages it affects. If you don't, then cargo-dist will search for a README* file in the package's root directory and the workspace's root directory (preferring the package).</p>
<h3 id="license-file"><a class="header" href="#license-file">license-file</a></h3>
<p>cargo-dist defaults to trying to include certain &quot;important&quot; static files in your executable-zips. A LICENSE is one of them.</p>
<p>If you specify a path to a license file, cargo-dist will use that for all packages it affects. Otherwise, cargo-dist will search for LICENSE* or UNLICENSE* files in the package's root directory and the workspace's root directory (preferring the package). If multiple are defined in the same directory, we will grab them all (this is necessary for the extremely common dual MIT/Apache license, which often results in two LICENSE-* files). </p>
<p>Note that the Cargo license-file flag only accepts one path, so it can't handle the dual-license-file case. This cargo feature largely exists as an escape hatch for weird licenses which can't be described by the SPDX format of the &quot;license&quot; field.</p>
<h2 id="workspacemetadatadist"><a class="header" href="#workspacemetadatadist">workspace.metadata.dist</a></h2>
<p>Cargo allows other tools to include their own project-wide settings in <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#the-metadata-table">metadata tables</a>. The one cargo-dist uses is <code>[workspace.metadata.dist]</code>, which must appear in your root Cargo.toml (whether or not it's <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">virtual</a>). You can override them on a per-package basis with <code>[package.metadata.dist]</code>, which accepts all the same fields (except for those which must be specified once globally, see the docs for each individual option).</p>
<h3 id="cargo-dist-version"><a class="header" href="#cargo-dist-version">cargo-dist-version</a></h3>
<blockquote>
<p>since 0.0.3</p>
</blockquote>
<p>Example: <code>cargo-dist-version = &quot;0.0.3&quot;</code> </p>
<p><strong>This can only be set globally</strong></p>
<p>This is added automatically by <code>cargo dist init</code>, and is a recording of its own version for the sake of reproducibility and documentation. When you run <a href="./cli.html#cargo-dist-generate-ci">generate-ci</a> the resulting CI scripts will use that version of cargo-dist to build your applications.</p>
<p>The syntax must be a valid <a href="https://docs.rs/semver/latest/semver/struct.Version.html">Cargo-style SemVer Version</a> (not a VersionReq!).</p>
<p>If you delete the key, generate-ci will just use the version of cargo-dist that's currently running.</p>
<h3 id="rust-toolchain-version"><a class="header" href="#rust-toolchain-version">rust-toolchain-version</a></h3>
<blockquote>
<p>since 0.0.3 (deprecated in 0.1.0)</p>
</blockquote>
<p>Example: <code>rust-toolchain-version = &quot;1.67.1&quot;</code> </p>
<blockquote>
<p>Deprecation reason: <a href="https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file">rust-toolchain.toml</a> is a more standard/universal mechanism for pinning toolchain versions for reproducibility. Teams without dedicated release engineers will likely benefit from unpinning their toolchain and letting the underlying CI vendor silently update them to &quot;some recent stable toolchain&quot;, as they will get updates/improvements and are unlikely to have regressions.</p>
</blockquote>
<p><strong>This can only be set globally</strong></p>
<p>This is added automatically by <code>cargo dist init</code>, recorded for the sake of reproducibility and documentation. It represents the &quot;ideal&quot; Rust toolchain to build your project with. This is in contrast to the builtin Cargo <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-rust-version-field">rust-version</a> which is used to specify the <em>minimum</em> supported Rust version. When you run <a href="./cli.html#cargo-dist-generate-ci">generate-ci</a> the resulting CI scripts will install that version of the Rust toolchain with <a href="https://rust-lang.github.io/rustup/">rustup</a>. There's nothing special about the chosen value, it's just a hardcoded &quot;recent stable version&quot;.</p>
<p>The syntax must be a valid rustup toolchain like &quot;1.60.0&quot; or &quot;stable&quot; (should not specify the platform, we want to install this toolchain on all platforms).</p>
<p>If you delete the key, generate-ci won't explicitly setup a toolchain, so whatever's on the machine will be used (with things like rust-toolchain.toml behaving as normal). Before being deprecated the default was to <code>rustup update stable</code>, but this is no longer the case.</p>
<h3 id="ci"><a class="header" href="#ci">ci</a></h3>
<blockquote>
<p>since 0.0.3</p>
</blockquote>
<p>Example: <code>ci = [&quot;github&quot;]</code></p>
<p><strong>This can only be set globally</strong></p>
<p>This is a list of CI backends you want to support, allowing subsequent runs of <a href="./cli.html#cargo-dist-generate-ci">generate-ci</a> to know what CI scripts to generate. Its presence also enables certain CI-specific features. For instance if &quot;github&quot; is included we'll try to generate the body for a Github Release and tell <a href="./installers.html">installers</a> to fetch binaries from a Github Release.  Once we introduce more CI backends we'll need to more completely rationalize what that means. In all likelihood each set of CI scripts will need to explicitly select just its own CI by passing <code>--ci=...</code> for every invocation.</p>
<p>&quot;github&quot; is currently the only supported CI backend.</p>
<p><code>cargo dist init</code> can set this if you pass <code>--ci=...</code></p>
<h3 id="targets"><a class="header" href="#targets">targets</a></h3>
<blockquote>
<p>since 0.0.3</p>
</blockquote>
<p>Example: <code>targets = [&quot;x86_64-unknown-linux-gnu&quot;, &quot;x86_64-apple-darwin&quot;, &quot;x86_64-pc-windows-msvc&quot;]</code></p>
<p>This is a list of <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">target platforms</a> you want your application(s) to be built for. In principle this can be overridden on a per-package basis but that is not well tested.</p>
<p>In v0.0.5 the only properly supported choices are:</p>
<ul>
<li>x64 macOS: &quot;x86_64-apple-darwin&quot;</li>
<li>x64 Windows: &quot;x86_64-pc-windows-msvc&quot;</li>
<li>x64 Linux: &quot;x86_64-unknown-linux-gnu&quot;</li>
<li>arm64 macOS (Apple silicon): &quot;aarch64-apple-darwin&quot; (supported added in v0.0.4)</li>
</ul>
<p>Future versions should hopefully introduce proper support for important targets like &quot;musl linux&quot;.</p>
<p>By default all runs of <code>cargo-dist</code> will be trying to handle all platforms specified here at once. If you specify <code>--target=...</code> on the CLI this will focus the run to only those platforms. As discussed in <a href="./concepts.html">concepts</a>, this cannot be used to specify platforms that are not listed in <code>metadata.dist</code>, to ensure different runs agree on the maximum set of platforms.</p>
<h3 id="installers"><a class="header" href="#installers">installers</a></h3>
<blockquote>
<p>since 0.0.3</p>
</blockquote>
<p>Example: <code>installers = [&quot;shell&quot;, &quot;powershell&quot;]</code></p>
<p>This is a list of installers you want to be made for your application(s). In principle this can be overridden on a per-package basis but that is not well tested. See <a href="./installers.html">the full docs on installers for the full list of values</a>.</p>
<p>See &quot;repository&quot; for some discussion on the &quot;Artifact Download URL&quot;.</p>
<h3 id="include"><a class="header" href="#include">include</a></h3>
<blockquote>
<p>since 0.0.3</p>
</blockquote>
<p>Example: <code>include = [&quot;my-cool-file.txt&quot;, &quot;../other-cool-file.txt&quot;, &quot;./some/dir/&quot;]</code></p>
<p>This is a list of additional <em>files</em> or <em>directories</em> to copy into the root of all <a href="./artifacts.html#executable-zip">executable-zips</a> that this setting affects. The paths are relative to the directory of the Cargo.toml that you placed this setting in. Globs are not supported.</p>
<h3 id="auto-includes"><a class="header" href="#auto-includes">auto-includes</a></h3>
<blockquote>
<p>since 0.0.3</p>
</blockquote>
<p>Example: <code>auto-includes = false</code></p>
<p>Allows you to specify whether cargo-dist should auto-include README, (UN)LICENSE, and CHANGELOG/RELEASES files in <a href="./artifacts.html#executable-zip">executable-zips</a>. Defaults to true.</p>
<h3 id="windows-archive"><a class="header" href="#windows-archive">windows-archive</a></h3>
<blockquote>
<p>since 0.0.5</p>
</blockquote>
<p>Example: <code>windows-archive = &quot;.tar.gz&quot;</code></p>
<p>Allows you to specify the file format to use for <a href="./artifacts.html#executable-zip">executable-zips</a> that target windows. The default is
&quot;.zip&quot;. Supported values:</p>
<ul>
<li>&quot;.zip&quot;</li>
<li>&quot;.tar.gz&quot;</li>
<li>&quot;.tar.xz&quot;</li>
<li>&quot;.tar.zstd&quot;</li>
</ul>
<p>See also unix-archive below.</p>
<h3 id="unix-archive"><a class="header" href="#unix-archive">unix-archive</a></h3>
<blockquote>
<p>since 0.0.5</p>
</blockquote>
<p>Example: <code>unix-archive = &quot;.tar.gz&quot;</code></p>
<p>Allows you to specify the file format to use for <a href="./artifacts.html#executable-zip">executable-zips</a> that target not-windows. The default is
&quot;.tar.xz&quot;. See &quot;windows-archive&quot; above for a complete list of supported values.</p>
<h3 id="dist"><a class="header" href="#dist">dist</a></h3>
<blockquote>
<p>since 0.0.3</p>
</blockquote>
<p>Example: <code>dist = false</code></p>
<p>Specifies whether cargo-dist should ignore this package. It primarily exists as an alternative for <code>publish=false</code> or an override for <code>publish=false</code>.</p>
<h3 id="npm-scope"><a class="header" href="#npm-scope">npm-scope</a></h3>
<blockquote>
<p>since 0.0.6</p>
</blockquote>
<p>Example <code>npm-scope = &quot;@axodotdev&quot;</code></p>
<p>Specifies that <a href="./installers.html#npm">npm installers</a> should be published under the given <a href="https://docs.npmjs.com/cli/v9/using-npm/scope">scope</a>. The leading <code>@</code> is mandatory. If you newly enable the npm installer in <code>cargo dist init</code>'s interactive UI, then it will give you an opportunity to add the scope.</p>
<p>If no scope is specified the package will be global.</p>
<h3 id="checksum"><a class="header" href="#checksum">checksum</a></h3>
<blockquote>
<p>since 0.1.0</p>
</blockquote>
<p>Example: <code>checksum = &quot;sha512&quot;</code></p>
<p>Specifies how to checksum <a href="./artifacts.html#executable-zip">executable-zips</a>. Supported values:</p>
<ul>
<li>&quot;sha256&quot; (default) - generate a .sha256 file for each archive</li>
<li>&quot;sha512&quot; - generate a .sha512 file for each archive</li>
<li>&quot;false&quot; - do not generate any checksums</li>
</ul>
<p>The hashes should match the result that sha256sum and sha512sum generate. The current format is just a file containing the hash of that file and nothing else.</p>
<p>Future work is planned to <a href="https://github.com/axodotdev/cargo-dist/issues/120">support more robust signed checksums</a>.</p>
<h3 id="precise-builds"><a class="header" href="#precise-builds">precise-builds</a></h3>
<blockquote>
<p>since 0.1.0</p>
</blockquote>
<p>Example: <code>precise-builds = true</code></p>
<p><strong>This can only be set globally</strong></p>
<p>Build only the required packages, and individually (default: false)</p>
<p>By default when we need to build anything in your workspace, we build your entire workspace with --workspace. This setting tells cargo-dist to instead build each app individually.</p>
<p>On balance, the Rust experts we've consulted with find building with --workspace to be a safer/better default, as it provides some of the benefits of a more manual <a href="https://docs.rs/cargo-hakari/latest/cargo_hakari/about/index.html">workspace-hack</a>, without the user needing to be aware that this is a thing.</p>
<p>TL;DR: cargo prefers building one copy of each dependency in a build, so if two apps in your workspace depend on e.g. serde with different features, building with --workspace, will build serde once with the features unioned together. However if you build each package individually it will more precisely build two copies of serde with different feature sets.</p>
<p>The downside of using --workspace is that if your workspace has lots of example/test crates, or if you release only parts of your workspace at a time, we build a lot of gunk that's not needed, and potentially bloat up your app with unnecessary features.</p>
<p>If that downside is big enough for you, this setting is a good idea.</p>
<h3 id="merge-tasks"><a class="header" href="#merge-tasks">merge-tasks</a></h3>
<blockquote>
<p>since 0.1.0</p>
</blockquote>
<p>Example: <code>merge-tasks = true</code></p>
<p><strong>This can only be set globally</strong></p>
<p>Whether we should try to merge otherwise-parallelizable tasks onto the same machine, sacrificing latency and fault-isolation for more the sake of minor effeciency gains.</p>
<p>For example, if you build for x64 macos and arm64 macos, by default we will generate ci which builds those independently on separate logical machines. With this enabled we will build both of those platforms together on the same machine, making it take twice as long as any other build and making it impossible for only one of them to succeed.</p>
<p>The default is <code>false</code>. Before 0.1.0 it was always <code>true</code> and couldn't be changed, making releases annoyingly slow (and technically less fault-isolated). This config was added to allow you to restore the old behaviour, if you really want.</p>
<h3 id="fail-fast"><a class="header" href="#fail-fast">fail-fast</a></h3>
<blockquote>
<p>since 0.1.0</p>
</blockquote>
<p>Example: <code>fail-fast = true</code></p>
<p><strong>This can only be set globally</strong></p>
<p>Whether failing tasks should make us give up on all other tasks. (defaults to false)</p>
<p>When building a release you might discover that an obscure platform's build is broken. When this happens you have two options: give up on the release entirely (<code>fail-fast = true</code>), or keep trying to build all the other platforms anyway (<code>fail-fast = false</code>).</p>
<p>cargo-dist was designed around the &quot;keep trying&quot; approach, as we create a draft Release
and upload results to it over time, undrafting the release only if all tasks succeeded.
The idea is that even if a platform fails to build, you can decide that's acceptable
and manually undraft the release with some missing platforms.</p>
<p>(Note that the dist-manifest.json is produced before anything else, and so it will assume
that all tasks succeeded when listing out supported platforms/artifacts. This may make
you sad if you do this kind of undrafting and also trust the dist-manifest to be correct.)</p>
<p>Prior to 0.1.0 we didn't set the correct flags in our CI scripts to do this, but now we do.
This flag was introduced to allow you to restore the old behaviour if you prefer.</p>
<h3 id="install-path"><a class="header" href="#install-path">install-path</a></h3>
<blockquote>
<p>since 0.1.0</p>
</blockquote>
<p>Example: <code>install-path = &quot;~/.my-app/&quot;</code></p>
<p>The strategy that script installers (<a href="./installers.html#shell">shell</a>, <a href="./installers.html#powershell">powershell</a>) should use for selecting a path to install things at, with 3 possible syntaxes:</p>
<ul>
<li>
<p><code>CARGO_HOME</code>: (default) installs as if <code>cargo install</code> did it (tries <code>$CARGO_HOME/bin/</code>, but if <code>$CARGO_HOME</code> isn't set uses <code>$HOME/.cargo/bin/</code>). Note that we do not (yet) properly update some of the extra metadata files Cargo maintains, so Cargo may be confused if you ask it to manage the binary.</p>
</li>
<li>
<p><code>~/some/subdir/</code>: installs to the given subdir of the user's <code>$HOME</code></p>
</li>
<li>
<p><code>$SOME_VAR/some/subdir</code>: installs to the given subdir of the dir defined by <code>$SOME_VAR</code></p>
</li>
</ul>
<blockquote>
<p>NOTE: <code>$HOME/some/subdir</code> is technically valid syntax but it won't behave the way you want on Windows, because <code>$HOME</code> isn't a proper environment variable. Let us handle those details for you and just use <code>~/subdir/</code>.</p>
</blockquote>
<p>All of these error out if none of the required env-vars are set to a non-empty value. </p>
<p>We do not currently sanitize/escape the path components (it's not really a security concern when the user is about to download+run an opaque binary anyway). In the future validation/escaping of this input will become more strict. We do appear to correctly handle spaces in paths on both windows and unix (i.e. <code>~/My cargo-dist Documents/bin/</code> works), but we won't be surprised if things misbehave on Interesting Inputs.</p>
<p>Future Improvements:</p>
<ul>
<li>In the future <a href="https://github.com/axodotdev/cargo-dist/issues/286">we may expand this setting to allow you to pass an array of options that are tried in sequence until one succeeds</a>.</li>
<li>In the future <a href="https://github.com/axodotdev/cargo-dist/issues/287">we may support XDG dirs</a></li>
<li>In the future <a href="https://github.com/axodotdev/cargo-dist/issues/288">we may support %windows dirs%</a></li>
</ul>
<p>(Please file an issue if you have other requirements!)</p>
<h2 id="subsetting-ci-flags"><a class="header" href="#subsetting-ci-flags">Subsetting CI Flags</a></h2>
<p>Several <code>metadata.dist</code> configs have globally available CLI equivalents. These can be used to select a subset of <code>metadata.dist</code> list for that run. If you don't pass any, it will be as-if you passed all the values in <code>metadata.dist</code>. You can pass these flags multiple times to provide a list. This includes:</p>
<ul>
<li><code>--target</code></li>
<li><code>--installer</code></li>
<li><code>--ci</code></li>
</ul>
<p>See <a href="./concepts.html#artifact-modes-selecting-artifacts">Artifact Modes</a> for how you might use this kind of subsetting.</p>
<p>Caveat: the default &quot;host&quot; Artifact Mode does something fuzzier with <code>--target</code> to allow you to build binaries that are usable on the current platform. Again see <a href="./concepts.html#artifact-modes-selecting-artifacts">Artifact Modes</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="artifacts"><a class="header" href="#artifacts">Artifacts</a></h1>
<ul>
<li><a href="artifacts.html#executable-zip">executable-zip</a></li>
<li><a href="artifacts.html#symbols">symbols</a></li>
<li><a href="artifacts.html#installers">installers</a></li>
</ul>
<p>cargo-dist's primary role is to produce &quot;Artifacts&quot;, either to use locally or to upload as part of a release announcement. Here's a listing of the supported kinds!</p>
<h2 id="executable-zip"><a class="header" href="#executable-zip">executable-zip</a></h2>
<p>executable-zips are the primary output of cargo-dist: a zip (or tarball) containing prebuilt executables/binaries for an app, along with additional static files like READMEs, LICENSES, and CHANGELOGs.</p>
<p>When you <a href="./concepts.html#defining-your-apps">tell us to build an App for a platform</a> we will make an executable-zip for it. Global <a href="./installers.html">installers</a> will fetch and unpack executable zips from wherever you uploaded them (currently Github Releases).</p>
<p>You can modify what files get included with the <a href="./config.html#include">include</a> and <a href="./config.html#auto-includes">auto-includes</a> configs.</p>
<p>Currently we always make .zip on windows and .tar.xz elsewhere. <a href="https://github.com/axodotdev/cargo-dist/issues/17">This will be made configurable</a>.</p>
<p>Some notes on how we build your executables:</p>
<ul>
<li>We currently always build <code>--workspace</code> <a href="https://docs.rs/cargo-hakari/latest/cargo_hakari/about/index.html#what-are-workspace-hack-crates">to keep things consistent</a></li>
<li>We currently <a href="./simple-guide.html#the-dist-profile">always build with <code>--profile=dist</code></a></li>
<li>We currently <a href="https://github.com/axodotdev/cargo-dist/issues/22">always build with default features</a></li>
<li>When targeting windows-msvc we will unconditionally <a href="https://rust-lang.github.io/rfcs/1721-crt-static.html">append &quot;-Ctarget-feature=+crt-static&quot;</a> to your RUSTFLAGS, which should just be the default for rustc but isn't for legacy reasons</li>
<li>We don't yet <a href="https://github.com/axodotdev/cargo-dist/issues/74">support cross-compilation</a>. We'll faithfully attempt the compile by passing <code>--target</code> to cargo as instructed but it will probably just fail.
<ul>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/75">linux-musl is slated for a future version</a></li>
</ul>
</li>
</ul>
<h2 id="symbols"><a class="header" href="#symbols">symbols</a></h2>
<p>This feature is currently disabled <a href="https://github.com/axodotdev/cargo-dist/issues/136">pending a rework</a>, but basically we want to save your debuginfo in the form of pdbs, dSYMs, etc. This should automatically happen as a side-effect of requiring executable-zips with the appropriate build settings to generate them.</p>
<h2 id="installers-1"><a class="header" href="#installers-1">installers</a></h2>
<p>Most other kinds of artifact are referred to as &quot;installers&quot;, because they generally exist as ways of downloading and installing the binaries that were made for the executable-zips.</p>
<p><a href="./installers.html">See the full docs on installers for details</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installers-2"><a class="header" href="#installers-2">Installers</a></h1>
<ul>
<li><a href="installers.html#supported-installers">Supported Installers</a>
<ul>
<li><a href="installers.html#shell">shell</a>
<ul>
<li><a href="installers.html#shell-adding-things-to-path">shell: adding things to PATH</a></li>
</ul>
</li>
<li><a href="installers.html#powershell">powershell</a>
<ul>
<li><a href="installers.html#powershell-adding-things-to-path">powershell: adding things to PATH</a></li>
</ul>
</li>
<li><a href="installers.html#npm">npm</a></li>
</ul>
</li>
<li><a href="installers.html#artifact-download-url">Artifact Download URL</a></li>
<li><a href="installers.html#unpacking-files">Unpacking Files</a></li>
<li><a href="installers.html#other-installation-methods">Other Installation Methods</a></li>
</ul>
<p>The core functionality of cargo-dist is to build your binaries and produce tarballs/zips containing them. Basically every other kind of file it produces is considered an &quot;installer&quot; that helps download/install those binaries.</p>
<blockquote>
<p>Currently all supported installers are &quot;global&quot;/&quot;universal&quot; installers that detect the current platform and download and unpack the appropriate tarball/zip. This currently requires CI support to be enabled so we can ensure the files are hosted somewhere and now where to fetch them from.</p>
<p>In the future we will allow you to specify the download URL manually, and will enable more self-contained &quot;vendored&quot; installers like <a href="https://github.com/axodotdev/cargo-dist/issues/23">Windows .msi</a> and <a href="https://github.com/axodotdev/cargo-dist/issues/24">macOS .dmg/.app</a>, as well as <a href="https://github.com/axodotdev/cargo-dist/issues/76">various</a> <a href="https://github.com/axodotdev/cargo-dist/issues/87">package-managers</a>.</p>
</blockquote>
<h2 id="supported-installers"><a class="header" href="#supported-installers">Supported Installers</a></h2>
<p>Currently supported installers include:</p>
<ul>
<li>&quot;shell&quot;: a shell script that fetches and installs executables</li>
<li>&quot;powershell&quot;: a powershell script that fetches and installs executables</li>
<li>&quot;npm&quot;: an npm project that fetches and runs executables (e.g. via npx)</li>
</ul>
<p>These keys can be specified via <a href="./config.html#installers"><code>installer</code> in your cargo-dist config</a>. The <a href="./cli.html#cargo-dist-init"><code>cargo dist init</code> command</a> provides an interactive UI for enabling/disabling them.</p>
<h3 id="shell"><a class="header" href="#shell">shell</a></h3>
<blockquote>
<p>since 0.0.3</p>
</blockquote>
<p>This provides a shell script (installer.sh) which detects the current platform, fetches the best possible <a href="./artifacts.html#executable-zip">executable-zip</a> from your <a href="installers.html#artifact-download-url">artifact download URL</a>, copies the binary into your <a href="./config.html#install-path">install-path</a>, and attempts to add that path to the user's PATH (see the next section for details).</p>
<p>This kind of installer is ideal for bootstrapping setup on a fairly bare-bones system.</p>
<p>An &quot;installer hint&quot; will be provided that shows how to install via <code>curl | sh</code>, like so:</p>
<pre><code class="language-sh">curl --proto '=https' --tlsv1.2 -LsSf https://github.com/axodotdev/cargo-dist/releases/download/v0.0.5/cargo-dist-v0.0.5-installer.sh | sh
</code></pre>
<p>Limitations/Caveats:</p>
<ul>
<li>Requires a well-defined <a href="installers.html#artifact-download-url">artifact download URL</a></li>
<li>Currently only really designed for &quot;linux&quot; and &quot;macOS&quot;, and won't detect other platforms properly (and certainly won't play nice with things like nixOS).</li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/75">Cannot detect situations where musl-based builds are appropriate</a> (static or dynamic) </li>
<li><a href="installers.html#unpacking-files">Relies on the user's installation of <code>tar</code> and <code>unzip</code> to unpack the files</a></li>
<li>Relies on the the user's installation of <code>curl</code> or <code>wget</code> to fetch the files</li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/307">Will throw out all files except for the binary, so the binary can't rely on assets included in the archive</a></li>
<li>Cannot run any kind of custom install logic</li>
</ul>
<p>In an ideal world all of these caveats improve (except for maybe relying on tar/unzip/curl/wget, that's kinda fundamental).</p>
<h4 id="shell-adding-things-to-path"><a class="header" href="#shell-adding-things-to-path">shell: adding things to PATH</a></h4>
<p>Here is a more fleshed out description of how the shell installer attempts to add the <a href="./config.html#install-path">install-path</a> to the user's PATH, and the limitations of that process.</p>
<p>The most fundamental limitation is that installers fundamentally cannot edit the PATH of the currently running shell (it's a parent process). Only an explicit <code>source some_file</code> (or the more portable <code>. some_file</code>) can do that. As such, it benefits an installer to try to install to a directory that will already be on PATH (such as <a href="https://doc.rust-lang.org/cargo/guide/cargo-home.html">CARGO_HOME</a>). Otherwise all we can do is prompt the user to run <code>source</code> themselves after the installer has run (or restart their shell to freshly source rcfiles).</p>
<p>The process we use to add <a href="./config.html#install-path">install-path</a> to the user's PATH is roughly the same process that rustup uses (hopefully making us harmonious with running rustup before/after one of our installer scripts). In the following description we will use <code>$install-path</code> as a placeholder for the path computed at install-time where the binaries get installed. Its actual value will likely look something like <code>$HOME/.myapp</code> or <code>$HOME/.cargo/bin</code>.</p>
<ul>
<li>we generate a shell script and write it to <code>$install-path/env</code> (let's call this <code>$env-path</code>)
<ul>
<li>the script checks if <code>$install-path</code> is in PATH already, and prepends it if not</li>
<li>prepending is used to ideally override system-installed binaries, as that is assumed to be desired when explicitly installing with not-your-system-package-manager</li>
<li>the <code>env</code> script will only be added if it doesn't already exist</li>
<li>if <code>install-path = &quot;CARGO_HOME&quot;</code>, then <code>$env-path</code> will actually be in the parent directory, mirroring the behaviour of rustup</li>
</ul>
</li>
<li>we add <code>. $env-path</code> to <code>$HOME/.profile</code>
<ul>
<li>this is just a more portable version of <code>source $install-path/env</code></li>
<li>this line will only be added if it doesn't exist (we also check for the <code>source</code> equivalent)</li>
<li>the file is created if it doesn't exist</li>
<li><a href="https://github.com/rust-lang/rustup/blob/bcfac6278c7c2f16a41294f7533aeee2f7f88d07/src/cli/self_update/shell.rs#L70-L76">rustup shotgun blasts this line into many more files like .bashrc and .zshenv</a>, while still <a href="https://github.com/rust-lang/rustup/issues/478">lacking proper support for fish</a> and other more obscure shells -- we opted to start conservative with just .profile</li>
</ul>
</li>
<li>if <code>$HOME/.profile</code> was edited, we prompt the user to <code>source &quot;$env-path&quot;</code> or restart their shell
<ul>
<li>although this is less portable than <code>. &quot;$env-path&quot;</code>, it's very easy to misread/miscopy the portable version (not as much of a concern for an rcfile, but an issue for humans)</li>
<li>hopefully folks on platforms where this matters are aware of this issue (or they can restart their shell)</li>
</ul>
</li>
</ul>
<h3 id="powershell"><a class="header" href="#powershell">powershell</a></h3>
<blockquote>
<p>since 0.0.3</p>
</blockquote>
<p>This provides a powershell script (installer.ps1) which detects the current platform, fetches the best possible <a href="./artifacts.html#executable-zip">executable-zip</a> from your <a href="installers.html#artifact-download-url">artifact download URL</a>, copies the binary into your <a href="./config.html#install-path">install-path</a>, and attempts to add that path to the user's PATH (see the next section for details).</p>
<p>This kind of installer is ideal for bootstrapping setup on a fairly bare-bones system.</p>
<p>An &quot;installer hint&quot; will be provided that shows how to install via <code>irm | iex</code> (the windows equivalent of <code>curl | sh</code>), like so:</p>
<pre><code class="language-sh">irm https://github.com/axodotdev/cargo-dist/releases/download/v0.0.5/cargo-dist-v0.0.5-installer.ps1 | iex
</code></pre>
<p>Limitations/Caveats:</p>
<ul>
<li>Requires a well-defined <a href="installers.html#artifact-download-url">artifact download URL</a></li>
<li>Currently only really designed for &quot;native windows&quot;, and won't detect other platforms properly</li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/75">Cannot detect situations where musl-based builds are appropriate</a> (static or dynamic) </li>
<li><a href="installers.html#unpacking-files">Relies on the user's installation of <code>tar</code> and <code>Expand-Archive</code> to unpack the files</a></li>
<li>Relies on the the user's installation of <code>Net.Webclient</code> to fetch the files</li>
<li><a href="https://github.com/axodotdev/oranda/issues/393">Won't work if run in cmd instead of powershell</a></li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/307">Will throw out all files except for the binary, so the binary can't rely on assets included in the archive</a></li>
<li>Cannot run any kind of custom install logic</li>
</ul>
<p>On the scale of Windows (where many people are still running Windows 7) commands like &quot;Expand-Archive&quot; and &quot;tar&quot; are in fact relatively new innovations. Any system that predates 2016 (PowerShell 5.0) certainly has no hope of working. I believe that someone running Windows 10 is basically guaranteed to work, and anything before that gets sketchier.</p>
<p>In an ideal world most of these caveats improve (except for maybe the requirement of PowerShell &gt;= 5.0 which is not pleasant to push past).</p>
<h4 id="powershell-adding-things-to-path"><a class="header" href="#powershell-adding-things-to-path">powershell: adding things to PATH</a></h4>
<p>Here is a more fleshed out description of how the powershell installer attempts to add the <a href="./config.html#install-path">install-path</a> to the user's PATH, and the limitations of that process.</p>
<p>The most fundamental limitation is that installers fundamentally cannot edit the PATH of the currently running shell (it's a parent process). Powershell does not have an equivalent of <code>source</code>, so to the best of our knowledge restarting the shell is the only option (which if using Windows Terminal seems to mean opening a whole new window, tabs aren't good enough). As such, it benefits an installer to try to install to a directory that will already be on PATH (such as <a href="https://doc.rust-lang.org/cargo/guide/cargo-home.html">CARGO_HOME</a>). (<a href="https://github.com/rust-lang/rustup/blob/bcfac6278c7c2f16a41294f7533aeee2f7f88d07/src/cli/self_update/windows.rs#L397-L409">rustup also sends a broadcast WM_SETTINGCHANGE message</a>, but we couldn't find any evidence that this does anything useful.)</p>
<p>The process we use to add <a href="./config.html#install-path">install-path</a> to the user's PATH is roughly the same process that rustup uses (hopefully making us harmonious with running rustup before/after one of our installer scripts). In the following description we will use <code>$install-path</code> as a placeholder for the path computed at install-time where the binaries get installed. Its actual value will likely look something like <code>C:\Users\axo\.myapp</code> or <code>C:\Users\.cargo\bin</code>.</p>
<ul>
<li>we load from the registry <code>HKCU:\Environment</code>'s &quot;Path&quot; Item</li>
<li>we check if <code>$install-path</code> is contained within it already</li>
<li>if not, we prepend it and write the value back
<ul>
<li>prepending is used to ideally override system-installed binaries, as that is assumed to be desired when explicitly installing with not-your-system-package-manager</li>
</ul>
</li>
<li>if we edited the registry, we prompt the user to restart their shell</li>
</ul>
<h3 id="npm"><a class="header" href="#npm">npm</a></h3>
<blockquote>
<p>since 0.0.6</p>
</blockquote>
<p>This provides a tarball containing an npm package (npm-package.tar.gz) which when installed into an npm project: detects the current platform, fetches the best possible <a href="./artifacts.html#executable-zip">executable-zip</a> from your <a href="installers.html#artifact-download-url">artifact download URL</a>, and copies the binary into your node_modules. This can be used to install the binaries like any other npm package, or to run them with <code>npx</code>.</p>
<p>This kind of installer is ideal for making a native Rust tool available to JS devs.</p>
<p>An &quot;installer hint&quot; will be provided that shows how to install via <code>npm</code> like so:</p>
<pre><code class="language-sh">npm install @axodotdev/cargodisttest@0.2.0
</code></pre>
<p><strong>cargo-dist does not publish the package for you, you need to do that manually once the tarball is built.</strong> Conveniently, npm supports publishing from a url-to-a-tarball directly, and since 0.0.7 we make our tarballs look like &quot;proper&quot; npm package tarballs, so you can just do this:</p>
<pre><code class="language-sh">npm publish URL_TO_TARBALL
</code></pre>
<p>You can find the URL to the tarball at the bottom of the Github Release, inside the collapsible &quot;assets&quot; dropdown (*-npm-package.tar.gz). The format of the url is:</p>
<pre><code class="language-text">&lt;repo&gt;/releases/download/&lt;tag&gt;/&lt;app-name&gt;-npm-package.tar.gz
</code></pre>
<p>Example:</p>
<p>https://github.com/axodotdev/oranda/releases/download/v0.0.3/oranda-npm-package.tar.gz</p>
<p>If you're cutting a stable release (not-prerelease), you can use the &quot;latest&quot; URL format:</p>
<p>https://github.com/axodotdev/oranda/releases/latest/download/oranda-npm-package.tar.gz</p>
<p>In the future we may <a href="https://github.com/axodotdev/cargo-dist/issues/245">introduce more streamlined CI-based publishing workflows</a>.</p>
<p><a href="./config.html#npm-scope">You can set the @scope the package is published under with the npm-scope cargo-dist config</a>.</p>
<p>We will otherwise do our best to faithfully translate <a href="https://doc.rust-lang.org/cargo/reference/manifest.html">any standard Cargo.toml values you set</a> to an equivalent in the npm package.json format (name, version, authors, description, homepage, repository, keywords, categories...).</p>
<p>The package will also include an npm-shrinkwrap.json file for the npm packages the installer uses, this is the same as package-lock.json but &quot;really for reals I want this to be respected even if it's installed into another project&quot;. Note that <a href="https://doc.rust-lang.org/cargo/commands/cargo-install.html#dealing-with-the-lockfile">cargo install similarly disrespects Cargo.lock unless you pass --locked</a>.</p>
<p>Limitations/Caveats:</p>
<ul>
<li>Requires a well-defined <a href="installers.html#artifact-download-url">artifact download URL</a></li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/75">Cannot detect situations where musl-based builds are appropriate</a> (static or dynamic) </li>
<li><a href="installers.html#unpacking-files">Relies on nodejs's builtin gzip support to unpack the files, which only works with .tar.gz</a></li>
<li>Cannot run any kind of custom install logic</li>
</ul>
<p>As a result of the <code>.tar.gz</code> limitation, <code>cargo dist init</code> will prompt you to change <a href="./config.html#windows-archive">windows-archive</a> and <a href="./config.html#unix-archive">unix-archive</a> to &quot;.tar.gz&quot; if you enable the npm installer, erroring if you decline.</p>
<h2 id="artifact-download-url"><a class="header" href="#artifact-download-url">Artifact Download URL</a></h2>
<p>All installers which rely on detecting the current platform and fetching &quot;your&quot; <a href="./artifacts.html#executable-zip">executable-zips</a> (archives) to install prebuilt binaries need to know where to fetch from. They do this by combining a base URL with the precomputed name of the archive. That base URL is the <em>Artifact Download URL</em>.</p>
<p>The Artifact Download URL effectively mandates that all archives for a Release must be stored in the same directory (or pretend to be with redirects), and must have the exact name that cargo-dist selected for them.</p>
<p>The Artifact Download URL is currently on defined if:</p>
<ul>
<li><a href="./config.html#ci">You have enabled Github CI</a></li>
<li><a href="./config.html#repository">All crates in your workspace agree on the Cargo &quot;repository&quot; key</a></li>
</ul>
<p>&quot;Agree&quot; here means that:</p>
<ul>
<li>At least one crate defines the key</li>
<li>Every other crate that bothers to set the key has the same value (modulo trailing &quot;/&quot;)</li>
</ul>
<p>If this is the case, then it will be:</p>
<pre><code class="language-text">{{repository}}/releases/download/{{tag}}
</code></pre>
<p>For instance the Artifact Download URL for cargo-dist 0.0.5 is:</p>
<pre><code class="language-text">https://github.com/axodotdev/cargo-dist/releases/download/v0.0.5/
</code></pre>
<p>In the future this will be made more configurable.</p>
<h2 id="unpacking-files"><a class="header" href="#unpacking-files">Unpacking Files</a></h2>
<p>cargo-dist theoretically allows you to build <a href="./artifacts.html#executable-zip">executable-zips</a> with any of the following formats:</p>
<ul>
<li>.tar.gz</li>
<li>.tar.xz</li>
<li>.tar.zstd</li>
<li>.zip</li>
</ul>
<p>(See <a href="./config.html#windows-archive">windows-archive</a> and <a href="./config.html#unix-archive">unix-archive</a> for details and defaults)</p>
<p>But that doesn't necessarily mean a random user can unpack those formats, and that <em>especially</em> doesn't mean an installer that's trying to bootstrap the installation by fetching one of those archives can. This section serves to document some known limitations of various systems' builtin unpacking utilities.</p>
<ul>
<li>
<p>On unix-y platforms <code>tar</code> tends to be available with .tar.gz and .tar.xz well-supported, but not .tar.zstd. <code>unzip</code> is also pretty standard for handling .zip files.</p>
</li>
<li>
<p>Modern Windows (~Windows 10) has a copy of bsd <code>tar</code>, but it <em>only</em> supports .tar.gz out of the box (and zip I think, but we use the similarly-new Expand-Archive command for that). The windows file explorer also seemingly has no idea how to open a .tar.gz, unlike a .zip which just pops open with a double click, so worse UX for anyone manually falling back to the raw archives. Both of these are relatively new commands that older Windows systems might lack (introduced in ~2016/2017).</p>
</li>
<li>
<p>The npm <code>binary-install</code> and <code>tar</code> packages only support .tar.gz (because nodejs provides a builtin gzip decoder and they just rely on that). There are seemingly packages for other formats but we have yet to cobble together a comprehensive implementation that combines them all.</p>
</li>
<li>
<p>The Rust ecosystem similarly requires individual packages for all these formats, but they all have pretty simple/uniform APIs so we were able to cobble together basic support without too much effort.</p>
</li>
</ul>
<h2 id="other-installation-methods"><a class="header" href="#other-installation-methods">Other Installation Methods</a></h2>
<p>cargo-dist projects can also theoretically be installed with the following, through no active effort of our own:</p>
<ul>
<li><a href="https://doc.rust-lang.org/cargo/commands/cargo-install.html">cargo-install</a> (just <a href="https://doc.rust-lang.org/cargo/commands/cargo-publish.html">cargo publish</a> like normal)</li>
<li><a href="https://github.com/cargo-bins/cargo-binstall">cargo-binstall</a> (the URL schema we use for Github Releases is auto-detected)</li>
</ul>
<p>In the future we might <a href="https://github.com/axodotdev/cargo-dist/issues/72">support displaying these kinds of install methods</a>.</p>
<p>Note that cargo-install is just building from the uploaded source with the --release profile, and so if you're relying on cargo-dist or unpublished files for some key behaviours, this may cause problems. <a href="https://doc.rust-lang.org/cargo/commands/cargo-install.html#dealing-with-the-lockfile">It also disrespects your lockfile unless you pass --locked</a>. You can more closely approximate cargo-dist's build with:</p>
<pre><code class="language-sh">cargo install --profile=dist --locked
</code></pre>
<p>Although that's still missing things like <a href="https://github.com/rust-lang/rfcs/blob/master/text/1721-crt-static.md">Windows crt-static workarounds</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-dist-cli-manual"><a class="header" href="#cargo-dist-cli-manual">cargo-dist CLI Manual</a></h1>
<ul>
<li><a href="cli.html#usage">Usage</a></li>
<li><a href="cli.html#commands">Commands</a></li>
<li><a href="cli.html#options">Options</a></li>
<li><a href="cli.html#global-options">GLOBAL OPTIONS</a>
<ul>
<li><a href="cli.html#-v---verbose-verbose"><code>-v, --verbose &lt;VERBOSE&gt;</code></a></li>
<li><a href="cli.html#-o---output-format-output_format"><code>-o, --output-format &lt;OUTPUT_FORMAT&gt;</code></a></li>
<li><a href="cli.html#--no-local-paths"><code>--no-local-paths</code></a></li>
<li><a href="cli.html#-t---target-target"><code>-t, --target &lt;TARGET&gt;</code></a></li>
<li><a href="cli.html#-i---installer-installer"><code>-i, --installer &lt;INSTALLER&gt;</code></a></li>
<li><a href="cli.html#-c---ci-ci"><code>-c, --ci &lt;CI&gt;</code></a></li>
<li><a href="cli.html#--tag-tag"><code>--tag &lt;TAG&gt;</code></a></li>
</ul>
</li>
<li><a href="cli.html#cargo-dist-build">cargo dist build</a>
<ul>
<li><a href="cli.html#usage-1">Usage</a></li>
<li><a href="cli.html#options-1">Options</a>
<ul>
<li><a href="cli.html#-a---artifacts-artifacts"><code>-a, --artifacts &lt;ARTIFACTS&gt;</code></a></li>
<li><a href="cli.html#-h---help"><code>-h, --help</code></a></li>
</ul>
</li>
<li><a href="cli.html#global-options-1">GLOBAL OPTIONS</a></li>
</ul>
</li>
<li><a href="cli.html#cargo-dist-init">cargo dist init</a>
<ul>
<li><a href="cli.html#usage-2">Usage</a></li>
<li><a href="cli.html#options-2">Options</a>
<ul>
<li><a href="cli.html#-y---yes"><code>-y, --yes</code></a></li>
<li><a href="cli.html#--no-generate-ci"><code>--no-generate-ci</code></a></li>
<li><a href="cli.html#--with-json-config-with_json_config"><code>--with-json-config &lt;WITH_JSON_CONFIG&gt;</code></a></li>
<li><a href="cli.html#-h---help-1"><code>-h, --help</code></a></li>
</ul>
</li>
<li><a href="cli.html#global-options-2">GLOBAL OPTIONS</a></li>
</ul>
</li>
<li><a href="cli.html#cargo-dist-generate-ci">cargo dist generate-ci</a>
<ul>
<li><a href="cli.html#usage-3">Usage</a></li>
<li><a href="cli.html#options-3">Options</a>
<ul>
<li><a href="cli.html#-h---help-2"><code>-h, --help</code></a></li>
</ul>
</li>
<li><a href="cli.html#global-options-3">GLOBAL OPTIONS</a></li>
</ul>
</li>
<li><a href="cli.html#cargo-dist-manifest">cargo dist manifest</a>
<ul>
<li><a href="cli.html#usage-4">Usage</a></li>
<li><a href="cli.html#options-4">Options</a>
<ul>
<li><a href="cli.html#-a---artifacts-artifacts-1"><code>-a, --artifacts &lt;ARTIFACTS&gt;</code></a></li>
<li><a href="cli.html#-h---help-3"><code>-h, --help</code></a></li>
</ul>
</li>
<li><a href="cli.html#global-options-4">GLOBAL OPTIONS</a></li>
</ul>
</li>
<li><a href="cli.html#cargo-dist-plan">cargo dist plan</a>
<ul>
<li><a href="cli.html#usage-5">Usage</a></li>
<li><a href="cli.html#options-5">Options</a>
<ul>
<li><a href="cli.html#-h---help-4"><code>-h, --help</code></a></li>
</ul>
</li>
<li><a href="cli.html#global-options-5">GLOBAL OPTIONS</a></li>
</ul>
</li>
<li><a href="cli.html#cargo-dist-help">cargo dist help</a>
<ul>
<li><a href="cli.html#usage-6">Usage</a></li>
<li><a href="cli.html#commands-1">Commands</a></li>
</ul>
</li>
</ul>
<blockquote>
<p>This manual can be regenerated with <code>cargo dist help-markdown</code></p>
</blockquote>
<p>Shippable packaging for Rust.</p>
<p>See 'init', 'build' and 'plan' for the 3 most important subcommands.</p>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<pre><code class="language-text">cargo dist [OPTIONS]
</code></pre>
<p>cargo dist <COMMAND></p>
<h3 id="commands"><a class="header" href="#commands">Commands</a></h3>
<ul>
<li><a href="cli.html#cargo-dist-build">build</a>: Build artifacts</li>
<li><a href="cli.html#cargo-dist-init">init</a>: Setup or update cargo-dist</li>
<li><a href="cli.html#cargo-dist-generate-ci">generate-ci</a>: Generate CI scripts for orchestrating cargo-dist</li>
<li><a href="cli.html#cargo-dist-manifest">manifest</a>: Generate the final build manifest without running any builds</li>
<li><a href="cli.html#cargo-dist-plan">plan</a>: Get a plan of what to build (and check project status)</li>
<li><a href="cli.html#cargo-dist-help">help</a>: Print this message or the help of the given subcommand(s)</li>
</ul>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<h3 id="global-options"><a class="header" href="#global-options">GLOBAL OPTIONS</a></h3>
<h4 id="-v---verbose-verbose"><a class="header" href="#-v---verbose-verbose"><code>-v, --verbose &lt;VERBOSE&gt;</code></a></h4>
<p>How verbose logging should be (log level)</p>
<p>[default: warn]<br />
[possible values: off, error, warn, info, debug, trace]</p>
<h4 id="-o---output-format-output_format"><a class="header" href="#-o---output-format-output_format"><code>-o, --output-format &lt;OUTPUT_FORMAT&gt;</code></a></h4>
<p>The format of the output</p>
<p>[default: human]<br />
[possible values: human, json]</p>
<h4 id="--no-local-paths"><a class="header" href="#--no-local-paths"><code>--no-local-paths</code></a></h4>
<p>Strip local paths from output (e.g. in the dist manifest json)</p>
<p>This is useful for generating a clean &quot;full&quot; manifest as follows:</p>
<p><code>cargo dist manifest --artifacts=all --output-format=json --no-local-paths</code></p>
<h4 id="-t---target-target"><a class="header" href="#-t---target-target"><code>-t, --target &lt;TARGET&gt;</code></a></h4>
<p>Target triples we want to build</p>
<p>If left unspecified we will use the values in <a href="./config.html#metadatadist">workspace.metadata.dist</a>, except for <code>cargo dist init</code> which will select some &quot;good defaults&quot; for you.</p>
<h4 id="-i---installer-installer"><a class="header" href="#-i---installer-installer"><code>-i, --installer &lt;INSTALLER&gt;</code></a></h4>
<p>Installers we want to build</p>
<p>If left unspecified we will use the values in <a href="./config.html#metadatadist">workspace.metadata.dist</a>. <code>cargo dist init</code> will persist the values you pass to that location.</p>
<p>Possible values:</p>
<ul>
<li>shell:      Generates a shell script that fetches/installs the right build</li>
<li>powershell: Generates a powershell script that fetches/installs the right build</li>
<li>npm:        Generates an npm project that fetches the right build to your node_modules</li>
</ul>
<h4 id="-c---ci-ci"><a class="header" href="#-c---ci-ci"><code>-c, --ci &lt;CI&gt;</code></a></h4>
<p>CI we want to support</p>
<p>If left unspecified we will use the value in <a href="./config.html#metadatadist">workspace.metadata.dist</a>. <code>cargo dist init</code> will persist the values you pass to that location.</p>
<p>Possible values:</p>
<ul>
<li>github: Generate github CI that uploads to github releases</li>
</ul>
<h4 id="--tag-tag"><a class="header" href="#--tag-tag"><code>--tag &lt;TAG&gt;</code></a></h4>
<p>The (git) tag to use for the Announcement that each invocation of cargo-dist is performing.</p>
<p>This tag serves two purposes: defining which apps we are Announcing new Releases for (and therefore building binaries and installers for); and picking an id to use for certain URLs. For instance the git tag associated with a Github Release is part of the URL to fetch artifacts from that release, which needs to be known by some installers!</p>
<p>The currently accepted formats are &quot;v{VERSION}&quot; and &quot;{PACKAGE_NAME}-v{VERSION}&quot; (&quot;v1.0.0&quot;, &quot;v0.1.0-prerelease1&quot;, &quot;my-app-v1.0.0&quot;, etc).</p>
<p>If you use the prefixed version then we will only Announce/Release that package's apps (and return an error if that is not in fact the package's current version). This is approp</p>
<p>If you use the unprefixed version then we will assume you're Announcing/Releasing all packages in the workspace that have that version. This is appropriate for workspaces that only have one app, or for monorepos that version all their apps in lockstep.</p>
<p>If you do not specify this tag we will attempt to infer it by trying to Announce/Release every app in the workspace, succeeding only if they all have the same version. The tag selected will be &quot;v{VERSION}&quot;.</p>
<p>In the future we may try to make this look at the current git tags or something?</p>
<p><br><br><br></p>
<h2 id="cargo-dist-build"><a class="header" href="#cargo-dist-build">cargo dist build</a></h2>
<p>Build artifacts</p>
<h3 id="usage-1"><a class="header" href="#usage-1">Usage</a></h3>
<pre><code class="language-text">cargo dist build [OPTIONS]
</code></pre>
<h3 id="options-1"><a class="header" href="#options-1">Options</a></h3>
<h4 id="-a---artifacts-artifacts"><a class="header" href="#-a---artifacts-artifacts"><code>-a, --artifacts &lt;ARTIFACTS&gt;</code></a></h4>
<p>Which subset of the Artifacts to build</p>
<p>Artifacts can be broken up into two major classes: &quot;local&quot; ones, which are made for each target system (executable-zips, symbols, MSIs...); and &quot;global&quot; ones, which are made once per app (curl-sh installers, npm package, metadata...).</p>
<p>Having this distinction lets us run cargo-dist independently on multiple machines without collisions between the outputs.</p>
<p>If let unspecified, we will pick a fuzzier &quot;host&quot; mode that builds &quot;as much as possible&quot; for the local system. This mode is appropriate for local testing/debugging/demoing. If no --target flags are passed on the CLI then &quot;host&quot; mode will try to intelligently guess which targets to build for, which may include building targets that aren't defined in your metadata.dist config (since that config may exclude the current machine!).</p>
<p>The specifics of &quot;host&quot; mode are intentionally unspecified to enable us to provider better out-of-the-box UX for local usage. In CI environments you should always specify &quot;global&quot; or &quot;local&quot; to get consistent behaviour!</p>
<p>[default: host]</p>
<p>Possible values:</p>
<ul>
<li>local:  Build target-specific artifacts like executable-zips and MSIs</li>
<li>global: Build unique artifacts like curl-sh installers and npm packages</li>
<li>host:   Fuzzily build &quot;as much as possible&quot; for the host system</li>
<li>all:    Build all the artifacts; useful for <code>cargo dist manifest</code></li>
</ul>
<h4 id="-h---help"><a class="header" href="#-h---help"><code>-h, --help</code></a></h4>
<p>Print help (see a summary with '-h')</p>
<h3 id="global-options-1"><a class="header" href="#global-options-1">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="cli.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-dist-init"><a class="header" href="#cargo-dist-init">cargo dist init</a></h2>
<p>Setup or update cargo-dist</p>
<p>This will interactively guide you through the process of selecting configuration options and will also automatically run 'cargo dist generate-ci' afterwards as necessary. It will also handle updating your project to a new version of cargo-dist if you're running one.</p>
<h3 id="usage-2"><a class="header" href="#usage-2">Usage</a></h3>
<pre><code class="language-text">cargo dist init [OPTIONS]
</code></pre>
<h3 id="options-2"><a class="header" href="#options-2">Options</a></h3>
<h4 id="-y---yes"><a class="header" href="#-y---yes"><code>-y, --yes</code></a></h4>
<p>Automatically accept all recommended/default values</p>
<p>This is equivalent to just mashing ENTER over and over during the interactive prompts.</p>
<h4 id="--no-generate-ci"><a class="header" href="#--no-generate-ci"><code>--no-generate-ci</code></a></h4>
<p>Don't automatically invoke 'cargo dist generate-ci' at the end</p>
<h4 id="--with-json-config-with_json_config"><a class="header" href="#--with-json-config-with_json_config"><code>--with-json-config &lt;WITH_JSON_CONFIG&gt;</code></a></h4>
<p>A path to a json file containing values to set in workspace.metadata.dist and package.metadata.dist, for building tools that edit these configs.</p>
<p>This is the same toml =&gt; json format that <code>cargo metadata</code> produces when reporting <code>workspace.metadata.dist</code>. There is some additional hierarchy for specifying which values go to which packages, but this is currently intentionally undocumented to give us some flexibility to change it.</p>
<h4 id="-h---help-1"><a class="header" href="#-h---help-1"><code>-h, --help</code></a></h4>
<p>Print help (see a summary with '-h')</p>
<h3 id="global-options-2"><a class="header" href="#global-options-2">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="cli.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-dist-generate-ci"><a class="header" href="#cargo-dist-generate-ci">cargo dist generate-ci</a></h2>
<p>Generate CI scripts for orchestrating cargo-dist</p>
<h3 id="usage-3"><a class="header" href="#usage-3">Usage</a></h3>
<pre><code class="language-text">cargo dist generate-ci [OPTIONS]
</code></pre>
<h3 id="options-3"><a class="header" href="#options-3">Options</a></h3>
<h4 id="-h---help-2"><a class="header" href="#-h---help-2"><code>-h, --help</code></a></h4>
<p>Print help (see a summary with '-h')</p>
<h3 id="global-options-3"><a class="header" href="#global-options-3">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="cli.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-dist-manifest"><a class="header" href="#cargo-dist-manifest">cargo dist manifest</a></h2>
<p>Generate the final build manifest without running any builds.</p>
<p>This command is designed to match the exact behaviour of 'cargo dist build' when passed the same flags, which is nice for consistency but annoying for anyone who doesn't understand cargo-dist's design really well.</p>
<p>Notably it will default to only talking about artifacts for the host system, and will produce paths to the build dir that may not exist (since the build wasn't run).</p>
<p>'cargo dist plan' is an alias for this command that picks nicer defaults by forcing a couple flags to have specific values. You probably want that.</p>
<h3 id="usage-4"><a class="header" href="#usage-4">Usage</a></h3>
<pre><code class="language-text">cargo dist manifest [OPTIONS]
</code></pre>
<h3 id="options-4"><a class="header" href="#options-4">Options</a></h3>
<h4 id="-a---artifacts-artifacts-1"><a class="header" href="#-a---artifacts-artifacts-1"><code>-a, --artifacts &lt;ARTIFACTS&gt;</code></a></h4>
<p>Which subset of the Artifacts to build</p>
<p>Artifacts can be broken up into two major classes: &quot;local&quot; ones, which are made for each target system (executable-zips, symbols, MSIs...); and &quot;global&quot; ones, which are made once per app (curl-sh installers, npm package, metadata...).</p>
<p>Having this distinction lets us run cargo-dist independently on multiple machines without collisions between the outputs.</p>
<p>If let unspecified, we will pick a fuzzier &quot;host&quot; mode that builds &quot;as much as possible&quot; for the local system. This mode is appropriate for local testing/debugging/demoing. If no --target flags are passed on the CLI then &quot;host&quot; mode will try to intelligently guess which targets to build for, which may include building targets that aren't defined in your metadata.dist config (since that config may exclude the current machine!).</p>
<p>The specifics of &quot;host&quot; mode are intentionally unspecified to enable us to provider better out-of-the-box UX for local usage. In CI environments you should always specify &quot;global&quot; or &quot;local&quot; to get consistent behaviour!</p>
<p>[default: host]</p>
<p>Possible values:</p>
<ul>
<li>local:  Build target-specific artifacts like executable-zips and MSIs</li>
<li>global: Build unique artifacts like curl-sh installers and npm packages</li>
<li>host:   Fuzzily build &quot;as much as possible&quot; for the host system</li>
<li>all:    Build all the artifacts; useful for <code>cargo dist manifest</code></li>
</ul>
<h4 id="-h---help-3"><a class="header" href="#-h---help-3"><code>-h, --help</code></a></h4>
<p>Print help (see a summary with '-h')</p>
<h3 id="global-options-4"><a class="header" href="#global-options-4">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="cli.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-dist-plan"><a class="header" href="#cargo-dist-plan">cargo dist plan</a></h2>
<p>Get a plan of what to build (and check project status)</p>
<p>If you want to know what running your cargo-dist CI will produce, this is the command for you! This is the exact command that CI will run to make its build plan and generate dist-manifest.json (although it adds --output-format=json so that it's machine-readable).</p>
<p>This is an alias for the lower-level 'manifest' command with the appropriate flags forced for asking for &quot;everything&quot;</p>
<p>cargo dist manifest --artifacts=all --no-local-paths</p>
<h3 id="usage-5"><a class="header" href="#usage-5">Usage</a></h3>
<pre><code class="language-text">cargo dist plan [OPTIONS]
</code></pre>
<h3 id="options-5"><a class="header" href="#options-5">Options</a></h3>
<h4 id="-h---help-4"><a class="header" href="#-h---help-4"><code>-h, --help</code></a></h4>
<p>Print help (see a summary with '-h')</p>
<h3 id="global-options-5"><a class="header" href="#global-options-5">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="cli.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-dist-help"><a class="header" href="#cargo-dist-help">cargo dist help</a></h2>
<p>Print this message or the help of the given subcommand(s)</p>
<h3 id="usage-6"><a class="header" href="#usage-6">Usage</a></h3>
<pre><code class="language-text">cargo dist help [COMMAND]
</code></pre>
<h3 id="commands-1"><a class="header" href="#commands-1">Commands</a></h3>
<ul>
<li><a href="cli.html#cargo-dist-build">build</a>: Build artifacts</li>
<li><a href="cli.html#cargo-dist-init">init</a>: Setup or update cargo-dist</li>
<li><a href="cli.html#cargo-dist-generate-ci">generate-ci</a>: Generate CI scripts for orchestrating cargo-dist</li>
<li><a href="cli.html#cargo-dist-manifest">manifest</a>: Generate the final build manifest without running any builds</li>
<li><a href="cli.html#cargo-dist-plan">plan</a>: Get a plan of what to build (and check project status)</li>
<li><a href="cli.html#cargo-dist-help">help</a>: Print this message or the help of the given subcommand(s)</li>
</ul>
<p>stderr:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-schema"><a class="header" href="#json-schema">JSON Schema</a></h1>
<p>Many cargo-dist commands when run with <code>--output-format=json</code> will output to stdout a format we call &quot;dist-manifest.json&quot;. This contains:</p>
<ul>
<li>Top-level facts about the Announcement (tag, announcement title, etc)</li>
<li>Info about the Apps being Released as part of the Announcement (&quot;releases&quot;)</li>
<li>Info about the Artifacts included in the Announcement (&quot;announcements&quot;)</li>
</ul>
<p>As a matter of forward-compat and back-compat, basically every field in the format should be treated as optional (which the schema reflects).</p>
<p>The latest schema can be found at:</p>
<p>https://github.com/axodotdev/cargo-dist/releases/latest/download/dist-manifest-schema.json</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
